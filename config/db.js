const data = {
  book: [
    {
      id: 1,
      title: "အင်းဝ ၊ ဗားကရာနှင့် မယ်နုအုတ်ကျောင်း",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 12,
    },
    {
      id: 2,
      title: "ရန်ကင်းတောင်(သို့)ငါးရံမင်းတောင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 3,
      title: "မင်းကွန်းပုထိုးတော်ကြီ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 4,
      title: "ကုသိုလ်တော်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 5,
      title: "ကောင်းမှုတော်ဘုရားအကြောင်း သိကောင်းစရာ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 6,
      title: "စူဠာမဏိ (သို့မဟုတ်) ဘုရင်နှင့်ပြည်သူ ကြည်ဖြူသည့်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 7,
      title: "ဓမ္မရံကြီးဘုရား သမိုင်း",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 8,
      title: "ပုဂံ ရွှေစည်းခုံစေတီတော် ဘုရားသမိုင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 9,
      title: "တန့်ကြည့်တောင်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 10,
      title: "ရန်ကင်းတောင်(သို့)ငါးရံမင်းတောင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 11,
      title: "မင်းကွန်းပုထိုးတော်ကြီ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 12,
      title: "ကုသိုလ်တော်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 13,
      title: "ကောင်းမှုတော်ဘုရားအကြောင်း သိကောင်းစရာ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 14,
      title: "စူဠာမဏိ (သို့မဟုတ်) ဘုရင်နှင့်ပြည်သူ ကြည်ဖြူသည့်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 15,
      title: "ဓမ္မရံကြီးဘုရား သမိုင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 16,
      title: "ပုဂံ ရွှေစည်းခုံစေတီတော် ဘုရားသမိုင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 17,
      title: "ဒုတိယမြန်မာနိုင်ငံတော်ကို ဦးဆုံးတည်ထောင်ခဲ့သူ တပင်ရွှေထီ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 18,
      title: "ဗိဿနိုးဘုရင်မပန်ထွာနှင့် သူ၏သစ္စာတော်ခံများ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 19,
      title: "ထီးနန်းမရသော ကုန်းဘောင်အိမ်ရှေ့မင်း (၃)ပါး",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 20,
      title: "စကြာဝတေးမင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 21,
      title: "နတ်သျှင်နောင် နှင့် ရာဇဓာတုကလျ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 22,
      title: "၃၇ မင်းနတ်သမိုင်း",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 23,
      title: "ဓမ္မရံကြီးဘုရား သမိုင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 24,
      title: "ပုဂံ ရွှေစည်းခုံစေတီတော် ဘုရားသမိုင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 25,
      title: "တန့်ကြည့်တောင်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 26,
      title: "ရန်ကင်းတောင်(သို့)ငါးရံမင်းတောင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 27,
      title: "မင်းကွန်းပုထိုးတော်ကြီ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 28,
      title: "ကုသိုလ်တော်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 29,
      title: "ကောင်းမှုတော်ဘုရားအကြောင်း သိကောင်းစရာ",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 30,
      title: "စူဠာမဏိ (သို့မဟုတ်) ဘုရင်နှင့်ပြည်သူ ကြည်ဖြူသည့်ဘုရား",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 31,
      title: "ဓမ္မရံကြီးဘုရား သမိုင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 32,
      title: "ပုဂံ ရွှေစည်းခုံစေတီတော် ဘုရားသမိုင်",
      image: "",
      published: "၁၉၉၆ ရန်ကုန်",
      totalPage: 100,
    },
    {
      id: 33,
      title: "Practical Nest.js Develop clean MVC web applications (Lim, Greg  Correa, Daniel)",
      image: "",
      published: "Publication Year",
      totalPage: 121,
    },
  ],
  author: [
    {
      id: 1,
      name: "သော်တာမင်း2",
      description:
        "1မြန်မာ့သမိုင်းတွင် ခရစ်နှစ် ၁၃၆၄ ခုနှစ်မှ ၁၇၅၁ ခုနှစ်အထိ နှစ် ၄ဝဝ နီးပါး သက်တမ်းရှည်ကြာခဲ့ပြီး မင်းနေပြည်တော် လေးကြိမ်ဖြစ်ခဲ့သည့် အင်းဝ သည် ပြည်တွင်းပြည်ပ၌ အထူးထင်ရှားသော သမိုင်းဝင်မြို့ဟောင်းတစ်ခုဖြစ်သည်။ အနောက် နိုင်ငံသားများက ပထမမြန်မာနိုင်ငံတော်(ပုဂံ ခေတ်)ကို Kingdom of Pagan ဟုလည်း ကောင်း၊ ဒုတိယမြန်မာနိုင်ငံတော်(တောင်ငူ ခေတ်)ကို Kingdom of Pegu ဟု လည်း ကောင်း၊ တတိယမြန်မာနိုင်ငံတော်(ကုန်းဘောင် ခေတ်)ကို Kingdom of Ava, Court of Ava ဟု လည်းကောင်း ရေးသားလေ့ရှိခဲ့ပြီး အင်းဝဖြစ်စေ၊ အမရပူရဖြစ်စေ နေပြည်တော်ကို အင်းဝ(Ava)ဟုသာ မှတ်တမ်းပြုခဲ့ကြသည်။",
    },
    {
      id: 2,
      name: "သော်တာမင်း1",
      description:
        "2မြန်မာ့သမိုင်းတွင် ခရစ်နှစ် ၁၃၆၄ ခုနှစ်မှ ၁၇၅၁ ခုနှစ်အထိ နှစ် ၄ဝဝ နီးပါး သက်တမ်းရှည်ကြာခဲ့ပြီး မင်းနေပြည်တော် လေးကြိမ်ဖြစ်ခဲ့သည့် အင်းဝ သည် ပြည်တွင်းပြည်ပ၌ အထူးထင်ရှားသော သမိုင်းဝင်မြို့ဟောင်းတစ်ခုဖြစ်သည်။ အနောက် နိုင်ငံသားများက ပထမမြန်မာနိုင်ငံတော်(ပုဂံ ခေတ်)ကို Kingdom of Pagan ဟုလည်း ကောင်း၊ ဒုတိယမြန်မာနိုင်ငံတော်(တောင်ငူ ခေတ်)ကို Kingdom of Pegu ဟု လည်း ကောင်း၊ တတိယမြန်မာနိုင်ငံတော်(ကုန်းဘောင် ခေတ်)ကို Kingdom of Ava, Court of Ava ဟု လည်းကောင်း ရေးသားလေ့ရှိခဲ့ပြီး အင်းဝဖြစ်စေ၊ အမရပူရဖြစ်စေ နေပြည်တော်ကို အင်းဝ(Ava)ဟုသာ မှတ်တမ်းပြုခဲ့ကြသည်။",
    },
    {
      id: 3,
      name: "သော်တာမင်း3",
      description:
        "3မြန်မာ့သမိုင်းတွင် ခရစ်နှစ် ၁၃၆၄ ခုနှစ်မှ ၁၇၅၁ ခုနှစ်အထိ နှစ် ၄ဝဝ နီးပါး သက်တမ်းရှည်ကြာခဲ့ပြီး မင်းနေပြည်တော် လေးကြိမ်ဖြစ်ခဲ့သည့် အင်းဝ သည် ပြည်တွင်းပြည်ပ၌ အထူးထင်ရှားသော သမိုင်းဝင်မြို့ဟောင်းတစ်ခုဖြစ်သည်။ အနောက် နိုင်ငံသားများက ပထမမြန်မာနိုင်ငံတော်(ပုဂံ ခေတ်)ကို Kingdom of Pagan ဟုလည်း ကောင်း၊ ဒုတိယမြန်မာနိုင်ငံတော်(တောင်ငူ ခေတ်)ကို Kingdom of Pegu ဟု လည်း ကောင်း၊ တတိယမြန်မာနိုင်ငံတော်(ကုန်းဘောင် ခေတ်)ကို Kingdom of Ava, Court of Ava ဟု လည်းကောင်း ရေးသားလေ့ရှိခဲ့ပြီး အင်းဝဖြစ်စေ၊ အမရပူရဖြစ်စေ နေပြည်တော်ကို အင်းဝ(Ava)ဟုသာ မှတ်တမ်းပြုခဲ့ကြသည်။",
    },
  ],
  categories: [
    {
      id: 1,
      name: "Mike tl",
    },
    {
      id: 2,
      name: "wow",
    },
    {
      id: 3,
      name: "omg",
    },
  ],
  bookContent: [
    {
      id: 1,
      bookId: 1,
      content:
        "1ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 1,
    },
    {
      id: 2,
      bookId: 1,
      content:
        "2ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 2,
    },
    {
      id: 3,
      bookId: 1,
      content:
        "3ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 3,
    },
    {
      id: 4,
      bookId: 2,
      content: "page1",
      page_no: 1,
    },
    {
      id: 5,
      bookId: 2,
      content: "page2",
      page_no: 2,
    },
    {
      id: 6,
      bookId: 3,
      content: "page1",
      page_no: 1,
    },
    {
      id: 7,
      bookId: 3,
      content: "page2",
      page_no: 2,
    },

    {
      id: 8,
      bookId: 1,
      content:
        "4ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 4,
    },
    {
      id: 9,
      bookId: 1,
      content:
        "5ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 5,
    },
    {
      id: 10,
      bookId: 1,
      content:
        "6ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 6,
    },
    {
      id: 11,
      bookId: 1,
      content:
        "7ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 7,
    },
    {
      id: 12,
      bookId: 1,
      content:
        "8ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 8,
    },
    {
      id: 13,
      bookId: 1,
      content:
        "9ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 9,
    },
    {
      id: 14,
      bookId: 1,
      content:
        "10ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 10,
    },
    {
      id: 15,
      bookId: 1,
      content:
        "11ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 11,
    },
    {
      id: 16,
      bookId: 1,
      content:
        "12ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 12,
    },

    {
      id: 17,
      bookId: 1,
      content:
        "13ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။ဖောက်သည်သည် အလွန်ထက်မြက်ပါက သူလိုချင်သော ရလဒ်ကို ရရှိနိုင်မည်ဖြစ်သည်။ ဝေဒနာရဲ့ ရလဒ်ကို မြင်ရင် ငြင်းစရာမရှိပါဘူး။ မည်သူမည်ဝါဖြစ်ပါစေ ဝေဒနာသည် မိမိတို့အကျိုးနှင့် ဆက်စပ်နေကြောင်းကို မသိကြသလို ဝေဒနာ၏ အကျိုးဆက်ကိုလည်း မသိကြ၊ ပြောချင်တာက သူအရမ်းလိုချင်တယ်။",
      page_no: 13,
    },
    {
      id: 18,
      bookId: 33,
      content:
        "Practical Nest.js\nDevelop clean MVC web applications\nDaniel Correa – Greg Lim\nPractical Books\nCopyright © 2022 by Daniel Correa\nAll Rights Reserved\n",
      page_no: 1,
    },
    {
      id: 19,
      bookId: 33,
      content:
        "Practical Nest.js\nby Daniel Correa and Greg Lim\nCopyright © 2022 by Daniel Correa. All rights reserved.\nAll rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form\nor by any means, without the author’s prior written permission, except in the case of brief quotations embedded in\ncritical articles or reviews.\nEvery effort has been made to prepare this book to ensure the accuracy of the information presented. However, the\ninformation contained in this book is sold without warranty, either express or implied. Neither the author or its\ndistributors, will be held liable for any damages caused or alleged to have been caused directly or indirectly by this\nbook.\nFirst Edition: January 2022.\n",
      page_no: 3,
    },
    {
      id: 20,
      bookId: 33,
      content:
        "Contributors\nAbout the author\nDaniel Correa has been a researcher and a software developer for several years. Daniel has a Ph.D. in Computer\nScience; currently, he is a professor at Universidad EAFIT in Colombia. He is interested in software architectures,\nframeworks (such as Laravel, Django, Nest, Express, Vue, React, Angular, and many more), web development, and\nclean code.\nDaniel is very active on Twitter; he shares tips about software development and reviews software engineering\nbooks. Contact Daniel on Twitter at @danielgarax.\nAbout the co-author\nGreg Lim is a technologist and author of several programming books. Greg has many years in teaching\nprogramming in tertiary institutions and he places special emphasis on learning by doing. Contact Greg at\nsupport@i-ducate.com or on Twitter at @greglim81.\n",
      page_no: 4,
    },
    {
      id: 21,
      bookId: 33,
      content:
        "Table of Contents\nPreface\nChapter 01 – Introduction\nChapter 02 – Online Store Running Example\nChapter 03 – Introduction to Nest and Installation\nChapter 04 – Handlebars\nChapter 05 – Introduction to MVC applications\nChapter 06 – Layout View\nChapter 07 – Index and About Pages\nChapter 08 – Refactoring Index and About Pages\nChapter 09 – Use of a Coding Standard\nChapter 10 – List Products with Dummy Data\nChapter 11 – Configuration of MySQL Database\nChapter 12 – Configuration of TypeORM\nChapter 13 – Product Entity\nChapter 14 – List Products with Database Data\nChapter 15 – Refactoring List Products\nChapter 16 – Admin Panel\nChapter 17 – List Products in Admin Panel\nChapter 18 – Create Products\nChapter 19 – Create Products with Images\nChapter 20 – Edit and Delete Products\nChapter 21 – Create Users\nChapter 22 – Login System\nChapter 23 – Validations\nChapter 24 – Authorization\nChapter 25 – Shopping Cart\nChapter 26 – Orders and Items\nChapter 27 – Product Purchase\nChapter 28 – Orders Page\nChapter 29 – Deploying to the Cloud – Clever-Cloud – MySQL Database\nChapter 30 – Deploying to the Cloud – Heroku – Nest Application\nChapter 31 – Continue your Nest Journey\n",
      page_no: 5,
    },
    {
      id: 22,
      bookId: 33,
      content:
        "Preface\nNest (NestJS) is a framework for building efficient, scalable Node.js server-side applications. We will use Nest to\ndevelop an Online Store application that uses several Nest features. The Online Store application will be the means\nto understand straightforward and complex Nest concepts and how Nest features and third-party libraries can be\nused to implement real-world applications.\nThe main difference between this book and other similar books, is that this book is not just about Nest. Instead, this\nbook is about a “clean” design and implementation of web applications using Nest. By ‘clean’, we refer to an\nunderstandable, maintainable, usable, and well-divided application.\nThe authors have developed several applications over many frameworks, including Laravel, Django, Nest, Express,\nFlask, Spring, Vue, Angular, and React. And we are going to use that knowledge to create a clean design and clean\ncode strategies which can be applied not just to Nest, but to the design and implementation of most web\napplications using frameworks such as Django, Laravel, Flask, Express, and more.\nThis book is written with brief explanations direct to the point. It includes tips, short discussions, and useful phrases\nfound in other books that we have read to provide you with a practical approach that will improve your coding\nskills.\nThis is a short book divided into 31 chapters, with six pages on average per chapter. It was designed not to\noverwhelm you. With this division, you will feel like you're making fast progress. We won’t cover all Nest features,\nbut some of the most important to develop MVC web applications.\nWe hope you enjoy this journey as we did when we wrote this book.\nWho is this book for?\nThis book is for web developers or programmers who want to learn Nest and improve their coding skills. No\nprevious knowledge of Nest is required. However, basic programming knowledge is required. This book is also\nsuitable for experienced Nest developers. They can revise previous concepts and learn new clean code strategies.\nDownload the example code files\nYou \ncan \ndownload \nthe \nexample \ncode \nfiles \nfor \nthis \nbook \nfrom \nthe \nGitHub \nrepository\nhttps://github.com/PracticalBooks/Practical-Nest. In it, you will find the code of each chapter. You can replicate\nthis book’s code or download the code directly from GitHub. If there's an update to the code, it will be updated on\nthe existing GitHub repository.\nQuestions and discussions\nIf you have questions about any aspect of this book or want to discuss something, we recommend you to use the\ndiscussion zone of the GitHub repository (see Fig. P-1). In that way, you can learn from other questions, and we can\nlearn from you. Besides, others in the community can answer your questions.\nFigure P-1. Discussion zone of the GitHub repository.\n",
      page_no: 6,
    },
    {
      id: 23,
      bookId: 33,
      content:
        "Additionally, you can email your questions to practicalbooksco@gmail.com. Please mention the book title in the\nsubject of your message.\nDownload colored images\nWe also provide a PDF file with colored images of the figures/diagrams used in this book. You can download it\nhere: https://github.com/PracticalBooks/Practical-Nest/tree/main/BookImages.\nGetting book updates\nIf you want to receive book updates, please email us at practicalbooksco@gmail.com. We will also subscribe you to\nour mailing list.\n",
      page_no: 7,
    },
    {
      id: 24,
      bookId: 33,
      content:
        "Chapter 01 – Introduction\nWe will begin our journey to understand and apply many Nest concepts and features to develop MVC web\napplications.\nThe book is divided into the following chapters. We will highlight the Nest concepts we will learn and third-party\nlibraries and tools we will use across the chapters.\n• Chapter 01 – Introduction.\n• Chapter 02 – Online Store running example.\n• Chapter 03 – Introduction to Nest and Installation: Nest, Node.js, and npm.\n• Chapter 04 – Handlebars: Handlebars and views.\n• Chapter 05 – Introduction to MVC applications.\n• Chapter 06 – Layout View: Bootstrap and Handlebars Partials.\n• Chapter 07 – Index and About Pages: Nest Controllers.\n• Chapter 08 – Refactoring Index and About Pages.\n• Chapter 09 – Use of a Coding Standard: ESLint.\n• Chapter 10 – List Products with Dummy Data: Nest Modules.\n• Chapter 11 – Configuration of MySQL Database: XAMPP, MySQL, and phpMyAdmin.\n• Chapter 12 – Configuration of TypeORM: Nest Databases and TypeORM.\n• Chapter 13 – Product Entity: TypeORM Entities.\n• Chapter 14 – List Products with Database Data: Nest Providers and Dependency Injection.\n• Chapter 15 – Refactoring List Products.\n• Chapter 16 – Admin Panel.\n• Chapter 17 – List Products in Admin Panel.\n• Chapter 18 – Create Products: forms.\n• Chapter 19 – Create Products with Images: multer and Interceptors.\n• Chapter 20 – Edit and Delete Products.\n• Chapter 21 – Create Users: bcrypt.\n• Chapter 22 – Login System: Session and Middleware.\n• Chapter 23 – Validations: validator.\n• Chapter 24 – Authorizations.\n• Chapter 25 – Shopping Cart.\n• Chapter 26 – Orders and Items: TypeORM relations.\n• Chapter 27 – Product Purchase.\n• Chapter 28 – Orders Page.\n• Chapter 29 – Deploying to the Cloud – Clever-Cloud – MySQL Database: Clever-Cloud.\n• Chapter 30 – Deploying to the Cloud – Heroku – Nest Application: Heroku.\n• Chapter 31 – Continue your Nest Journey.\nIn this book, we will develop an Online Store. This Online Store will serve us to understand some of the more\nimportant Nest concepts. Figures 1-1, 1-2, 1-3, and 1-4 show the kind of application we will develop.\n",
      page_no: 8,
    },
    {
      id: 25,
      bookId: 33,
      content:
        "Figure 1-1. List of products page.\nFigure 1-2. Product page.\nFigure 1-3. Shopping cart page.\n",
      page_no: 9,
    },
    {
      id: 26,
      bookId: 33,
      content: "Figure 1-4. Admin panel page.\nLet’s start our journey!\n",
      page_no: 10,
    },
    {
      id: 27,
      bookId: 33,
      content:
        "Chapter 02 – Online Store Running Example\nUsing a running example is a common strategy in programming books. A running example is an example where we\nvisit repeatedly throughout the book. It provides a practical way to illustrate the concepts of a methodology,\nprocess, tool, or technique. In this case, we define an Online Store running example.\nOnline Store is a web application where users place orders to buy products.\nLet’s define the application scope for the app.\n• Home page will display a welcome message and some images.\n• About page will display information about the online store and developers.\n• Products page will display the available products information. You can click on a specific product and see its\ninformation.\n• Cart page will display the products added to the cart and the total price to be paid. A user can remove products\nfrom the cart and make purchases.\n• Login page will display a form to allow users to log in to the application.\n• Register page will display a form to allow users to sign up for accounts.\n• My orders page will display the orders placed by the logged in user.\n• Admin panel will contain sections to manage the store’s products (create, update, delete, and list them).\nThe online store will be implemented with Nest (Node.js), MySQL database, Bootstrap (a CSS framework), and\nHandlebars (HBS; a templating system). We will learn about these elements in the upcoming chapters.\nBelow is a class diagram to illustrate the application scope and design (see Fig. 2-1). We have a User  class with its\ndata (id, name, email, password, etc.) which can place Orders . Each Order  is composed of one or more Items\nwhich are related to a single Product . Each Product  will have its corresponding data (id, name, description,\nimage, etc.).\nFigure 2-1. Online Store class diagram.\nThis book is not about class diagrams, so we won’t explain other details in the class diagram. You will see a\nrelationship between the code and this diagram as you advance through the book. This diagram serves as a blueprint\nfor the construction of our application.\nTIP: Designing a class diagram before starting to code helps us understand the application’s\nscope and identify important data. It also helps us know how the application elements are related.\nYou can share a diagram like this with your team or colleagues, obtain quick feedback, and make\nadjustments as needed. Since it is a diagram, changes can be made quickly. Else, when the\nproject has been coded, the replacement cost will be higher to move data from one class to\nanother. Let’s check this phrase from (2015 – Newman, S. - Building microservices) book. “I\ntend to do much of my thinking in the place where the cost of change and the cost of mistakes is\nas low as it can be: the whiteboard.”\nNow that we have considered the kind of application we want to build, let’s next understand what Nest is and how\nto install it.\n",
      page_no: 11,
    },
    {
      id: 28,
      bookId: 33,
      content:
        'Chapter 03 – Introduction to Nest and Installation\nIntroduction to Nest\nNest \n(NestJS) \nis \na \nframework \nfor \nbuilding \nefficient, \nscalable \nNode.js \nserver-side \napplications\n(https://docs.nestjs.com/). It uses JavaScript, is built with and fully supports TypeScript. It combines elements of\nOOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).\nUnder the hood, Nest makes use of robust HTTP Server frameworks like Express (https://expressjs.com/).\nNest vs Angular, React, and Vue\nThe main difference between Nest and Angular, React, and Vue is that Nest is used to develop server-side\napplications, while Angular, React, and Vue are used to develop front-end applications.\nNest vs Express\nBoth Nest and Express are used to develop server-side applications. The main difference is that Express is a\nminimalist framework which does not provide a predefined architecture. Instead, Nest provides an out-of-the-box\napplication architecture which allows developers and teams to create highly testable, scalable, loosely coupled, and\neasily maintainable applications. The Nest architecture is heavily inspired by Angular.\nNest v8\nWhen writing this book, the latest version is Nest 8 which we will use to build our Online Store application.\nNote: A new Nest version might be available at the time you are reading this book. We recommend you continue\nusing Nest 8 for this project. Once you complete this book, you can upgrade to the latest Nest version. In this way,\nmost of the code will remain reusable. Some others might require minor adjustments.\nRequirements (Node.js and npm)\nTo create Nest applications, we need to install Node.js and npm.\nNode.js\nNode.js is a free, open-source server environment. Node.js uses JavaScript on the server. Node.js represents a\n"JavaScript everywhere" paradigm, unifying web application development around a single programming language,\nrather than different languages for server-side and client-side scripts.\nIf you don’t have Node.js installed, go to https://nodejs.org/en/download/. Download and install it.\nOnce Node.js is installed, go to the Terminal, and execute the following command.\nExecute in Terminal\nnode -v\nIf the installation was successful, you would see a result as presented in Fig 3-1.\nFigure 3-1. Checking Node.js version.\nnpm\nnpm is a package manager for Node.js. It consists of a command line client, called npm, and an online database of\npublic and paid-for private packages, called the npm registry. With npm, you can declare the libraries your project\ndepends on, and it will manage (install/update) them for you.\nThe Node.js installer already includes the npm package manager. So, we already have npm. Go to the Terminal and\nexecute the following command.\nExecute in Terminal\nnpm -v\nYou would see a result as presented in Fig 3-2.\n',
      page_no: 12,
    },
    {
      id: 29,
      bookId: 33,
      content:
        "Figure 3-2. Checking composer version.\nCreate a new Nest project\nThere are a couple of ways of creating Nest projects. We will use the Nest CLI in this book. The Nest CLI is a\ncommand-line interface tool that helps you initialize, develop, and maintain your Nest applications. To install the\nNest CLI, go to the Terminal, and execute the following command.\nExecute in Terminal\nnpm install -g @nestjs/cli\nTo create a Nest project, open your Terminal, and in a location of your choice, execute the following command.\nExecute in Terminal\nnest new online-store\nYou will be asked “Which package manager would you like to use?” -> Select “npm” and press “Enter”.\nThe previous command creates a new Nest project inside the online-store  folder.\nNext, in your Terminal, move to the online-store  folder, and run the application with the following commands.\nExecute in Terminal\ncd online-store\nnpm run start\nThe npm run start  command executes a script command defined in the package.json  file. This script executes\nnest start  which launches the server (see Fig. 3-3).\nFigure 3-3. Running Nest project.\nIf the installation and setup were successful, open your browser at http://localhost:3000/ and you should see a hello-\nworld message as shown in Fig. 3-4.\nFigure 3-4. Nest default main page.\nNote: you can stop the server with Ctrl + C  (on Windows), or Cmd + C (on Mac) .\nNest project structure\nFig. 3-5 shows the Nest project structure. We will not explain all the folders and files since we want to start\ndeveloping our web applications quickly. We will explain some of the more important ones. The others will be\ncovered in upcoming chapters.\n",
      page_no: 13,
    },
    {
      id: 30,
      bookId: 33,
      content:
        "Figure 3-5. Nest project structure.\n• dist/*: The /dist  folder stands for distributable. The /dist  folder contains the compiled version of the source\ncode. It is the code used in production. We will see how to generate the application’s production code later.\n• node_modules/*:  The  /node_modules  folder contains all libraries downloaded from npm. The\nlibraries/dependencies are listed in the package.json  file. When we create a Nest project, internally, Nest uses\nnpm to download and install all required libraries in the /node_modules  folder.\n• src/*: Nest projects contain a src/  folder populated with several core files.\n• src/main.ts: This is the entry file of the application. It uses the core function NestFactory to create a Nest\napplication instance. The main.ts  includes an async function, which bootstraps our application.\n• src/app.controller.spec.ts: Stores the unit tests for the app controller. We won’t design unit tests in this book\nsince it is out of the book’s scope.\n• src/app.module.ts: The root module of the application.\n• src/app.controller.ts: A basic app controller with a single route.\n• src/app.service.ts: A basic app service with a single method.\n• test/*: The /test folder is used to define the application’s end-to-end tests. Again, we won’t use it since it is out\nof the book’s scope.\n• package.json: It holds metadata relevant to the project and is used for managing the project’s dependencies,\nscripts, version and many more.\n• tsconfig.json: It contains the TypeScript compiler configuration for our app.\nAs you can see, several files with different functionalities are used in the construction of Nest applications. For\nnow, we will remove and modify some of those files to make our learning process more manageable. Later, we will\nre-create some of those files again.\nSimplified Hello-World\nLet’s make some changes to simplify our initial project to make it easier to understand.\nsrc/app.controller.spec.ts and src/app.service.ts\nWe won’t use Nest services yet, so we delete the app.service.ts file. We will also remove the unit tests for the app\ncontroller by deleting the app.controller.spec.ts  file.\nsrc/app.controller.ts\nIn src/app.controller.ts , remove the AppService  import, remove the constructor , and replace the getHello\nreturn  with the following in bold.\n",
      page_no: 14,
    },
    {
      id: 31,
      bookId: 33,
      content:
        "Modify Bold Code\nimport { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\n@Controller()\nexport class AppController {\nconstructor(private readonly appService: AppService) {}\n@Get()\ngetHello(): string {\nreturn '<b>Hello World!</b>';\n}\n}\nWe removed everything related to the app service (since we removed the app.service.ts file). Instead of using the\nAppService , we returned a simple “Hello World!” text. We wrapped this text around a “b” tag. This is an HTML\ntag which displays our text in bold. As you can see, we have some Nest annotations (i.e., @Get  and\n@Controller ), and some methods. We will explain them in upcoming chapters.\nFor now, know that the main app route (http://localhost:3000/) will invoke the getHello  method which returns the\n“Hello World!” text.\nsrc/app.module.ts\nIn src/app.module.ts , remove the AppService  import and also the providers  parameter.\nModify Bold Code\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n@Module({\nimports: [],\ncontrollers: [AppController],\nproviders: [AppService],\n})\nexport class AppModule {}\nWe will explain Nest Modules in upcoming chapters.\nRunning the app\nIn the Terminal, stop the server with Ctrl + C  (on Windows), or Cmd + C (on Mac), and execute the following\ncommand.\nExecute in Terminal\nnpm run start:dev\nThe npm run start:dev  launches the server and watches your files. It rebuilds the app as you make changes to those\nfiles. This is the command that we will use from now. Otherwise, we will need to stop and start the server each time\nwe have a code change.\nNow, you can check the “Hello World!” message in bold (see Fig. 3-6).\nFigure 3-6. Nest main page.\nIn the next chapter, we will include the view layer to our application to avoid defining our HTML code inside our\ncontrollers, i.e.:\nAnalyze Code\ngetHello(): string {\nreturn '<b>Hello World!</b>';\n}\n",
      page_no: 15,
    },
    {
      id: 32,
      bookId: 33,
      content:
        "Chapter 04 – Handlebars\nIn the previous chapter, we defined HTML code inside the controllers’ methods. This strategy does not scale well\nsince we are mixing logic code with view code. Nest official documentation suggests using a template engine to\nrender our HTML views, and the recommended template engine is called Handlebars.\nIntroducing Handlebars\nHandlebars (https://handlebarsjs.com/) is a simple templating language where you pass in input objects to output\nHTML. Handlebars templates look like regular text with embedded Handlebars expressions.\nFor example, the following code shows an excerpt of a simple view in Nest using Handlebars.\nAnalyze Code\n<p>{{firstname}} {{lastname}}</p>\nA handlebars expression is a {{ , some contents, followed by a }} . When the template is executed, these\nexpressions are replaced with values from an input object. For example, we can pass firstname  and lastname\nobjects from a Nest controller to a Handlebars view; the template is then executed and firstname  and lastname\nwill be replaced with their object values. We will see more examples in upcoming chapters.\nInstalling Handlebars\nLet’s first install Handlebars in our Online Store project. In the Terminal, go to the project directory, and execute\nthe following:\nExecute in Terminal\nnpm install --save hbs\nThis installs Handlebars in our project. It modifies our package.json  file to include the  hbs  dependency and\nincludes the  hbs library inside the node_modules  folder.\nConfiguring Handlebars\nOnce the installation is complete, we need to configure the Nest express instance to use Handlebars. In src/main.ts ,\nmake the following changes in bold.\nModify Bold Code\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { join } from 'path';\nasync function bootstrap() {\nconst app = await NestFactory.create(AppModule);\nconst app = await NestFactory.create<NestExpressApplication>(\nAppModule,\n);\napp.useStaticAssets(join(__dirname, '..', 'public'));\napp.setBaseViewsDir(join(__dirname, '..', 'views'));\napp.setViewEngine('hbs');\nawait app.listen(3000);\n}\nbootstrap();\nLet’s analyze the code by parts.\nAnalyze Code\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { join } from 'path';\nWe import the NestExpressApplication  interface which provides a set of Express methods. These methods will be\navailable through the app  object later. We also import the join  function from the Node.js path  library. The path\nlibrary provides utilities for working with file and directory paths.\nAnalyze Code\nconst app = await NestFactory.create<NestExpressApplication>(\nAppModule,\n);\n",
      page_no: 16,
    },
    {
      id: 33,
      bookId: 33,
      content:
        "app.useStaticAssets(join(__dirname, '..', 'public'));\napp.setBaseViewsDir(join(__dirname, '..', 'views'));\napp.setViewEngine('hbs');\nWe create a new app object which has access to a set of NestExpressApplication  methods. We then invoke three\nmethods. We tell Express that the public  folder will be used for storing static assets( useStaticAssets  method).\nviews  folder will contain templates( setBaseViewsDir  method), and we specify that the hbs  template engine will\nbe used to render HTML output( setViewEngine  method).\nUsing Handlebars\nFinally, let’s refactor our code to avoid using HTML inside controller’s methods and use Handlebars instead.\nIndex view\nIn the project root directory, create a folder called views . This is the folder where we store our views. In views/\ncreate a new file called index.hbs  and fill it with the following code.\nAdd Entire Code\n<b>Hello World!</b>\nApp.controller.ts\nDelete all the existing code in src/app.controller.ts  and fill it with the following.\nReplace Entire Code\nimport { Controller, Get, Render } from '@nestjs/common';\n@Controller()\nexport class AppController {\n@Get(\"/\")\n@Render('index')\nindex() {}\n}\nLet’s analyze some important changes in src/app.controller.ts . First, we import the Render  decorator used to\nrender Handlebars views. Then, we add the “/” route to the @Get  decorator. This is not necessary since the default\nroute is already “/”; however, it improves the code readability. We use the @Render  decorator for the index\nmethod (check that we change the  getHello  method name to index ). In this case, we specify that the  index\nmethod will render the index  view.\nIn summary, once a user visits the “/” route, Nest will execute the AppController index  method, which will render\nthe index  view.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nIf you go to http://localhost:3000/ you will see the “Hello World!” message in bold (see Fig. 4-1).\nFigure 4-1. Online Store index page with Handlebars.\n",
      page_no: 17,
    },
    {
      id: 34,
      bookId: 33,
      content:
        "Chapter 05 – Introduction to MVC applications\nThere are different ways of designing and implementing web applications. For example, you can create an entire\nweb application by placing all your code in a single file. However, finding an error in such a file (which contains\nthousands of lines of code) is not an easy task. Other approaches split the code over different files and folders. You\nwill even find approaches that split your application over different small applications distributed over several\nservers (the distribution of these servers is not an easy task).\nAs you can see, structuring your code is not an easy task. That’s the reason why developers and computer scientists\nhave developed what is called software architectural patterns. Software architectural patterns are structural\nlayouts used to solve commonly faced software design problems. With these patterns startups or novice developers\ndo not have to “reinvent the wheel” each time they start a new project. There are many architectural patterns, such\nas model-view-controller, layers, service-oriented, and micro-services. Each one has its advantages and\ndisadvantages. Many are widely adopted. Still, one of the most used is the model-view-controller pattern.\nModel-view-controller (MVC) is a software architectural pattern commonly used to develop web applications\ncontaining user interfaces. This pattern divides the application into three interconnected elements.\n• Model contains the business logic of the application. For example, the online store application product data\nand its functions.\n• View contains the user interface of the application. For example, a view to register products or users.\n• Controller acts as an interface between model and view elements. For example, a product controller collects\ninformation from a “create product” view and passes it to the product model to be stored in the database.\nNest provides support for the MVC pattern thanks to the integration of the Handlebars templating engine. Other\nsimilar frameworks provide support to this popular pattern too. We will see this pattern in action (with actual code)\nlater.\nThe MVC pattern provides some advantages: better code separation, multiple team members can work and\ncollaborate simultaneously, finding an error is easier, and maintainability is improved. Fig. 5-1 shows the Online\nStore software architecture we will implement in this book. It can be a little overwhelming now, but you will\nunderstand the elements of this architecture when you finish this book. We will review the architecture in the final\nchapters.\n",
      page_no: 18,
    },
    {
      id: 35,
      bookId: 33,
      content:
        "Figure 5-1. Online Store software architecture.\nLet’s have a quick analysis of this architecture:\n• On the left, we have clients (users of our application e.g., browsers in mobile/desktop devices). Clients connect\nto the application through the Hypertext Transfer Protocol (HTTP). HTTP gives users a way to interact with\nour web application.\n• On the right, we have the server where we place our application code.\n• Clients’ interactions are connected to the main application file (main.ts). This file loads the root module\n(AppModule), which internally will load other modules (described in Chapter 10), and those modules pass the\nclients’ interactions to the controllers.\n• Controllers (described in Chapter 7) execute the clients’ interactions based on the specific requested routes, i.e.\n(“/products”) or (“/cart”) routes. Controllers communicate with models (described in Chapter 13), and pass\ninformation to the views (described in Chapter 4), which are finally delivered to the clients as HTML, CSS,\nand JavaScript code.\nWe highlight the Model, View and Controller layers in grey. We have four models (entities) corresponding to the\nclasses defined in our class diagram (in Fig. 2-1). As mentioned, there are different approaches to implement web\napplications with Nest. There are even different versions of MVC used in a Nest application. In the following\nchapters, we will see advantages of adopting the MVC architecture defined in Fig. 5-1.\n",
      page_no: 19,
    },
    {
      id: 36,
      bookId: 33,
      content:
        "Chapter 06 – Layout View\nIntroducing Bootstrap\nBootstrap is the most popular CSS framework for developing responsive and mobile-first websites (see Fig. 6-1).\nFor Nest projects, a developer can design the user interface from scratch. But because this book is not about user\ninterfaces, we will take advantage of CSS frameworks (such as Bootstrap) and use a starter template to still create\nsomething that looks professional. You can find out more about Bootstrap at: https://getbootstrap.com/.\nFigure 6-1. Bootstrap website.\nIntroducing Handlebars Partials\nMost web applications maintain the same general layout across various pages (common header, navigation bar,\nfooter). However, it would be incredibly cumbersome to maintain our application if we had to repeat the entire\nheader, navbar, footer HTML in every view. Fortunately, we can define this layout as a single hbs file and use it\nthroughout our application.\nConfiguring Handlebars Partials\nTo create this common layout, we need to configure Handlebars Partials. Handlebars Partials are normal\nHandlebars views that may be called by other views. We will configure Handlebars Partials and include a library to\nwatch for changes in those Partials.\nInstalling hbs-utils\nHbs-utils provides a set of functions that are useful when using hbs. One such function allows us to watch changes\nin Partials. Let’s install hbs-utils in our Online Store project. In the Terminal, go to the project directory, and\nexecute the following:\nExecute in Terminal\nnpm install hbs-utils\nThis installs hbs-utils  in our project. It modifies our package.json  file to include the  hbs-utils  dependency and\nincludes the  hbs-utils library inside the node_modules  folder.\nModifying src/main.ts\nIn src/main.ts , make the following changes in bold.\nModify Bold Code\n…\nimport { AppModule } from './app.module';\nimport * as hbs from 'hbs';\nimport * as hbsUtils from 'hbs-utils';\nasync function bootstrap() {\nconst app = await NestFactory.create<NestExpressApplication>(\nAppModule,\n);\napp.useStaticAssets(join(__dirname, '..', 'public'));\napp.setBaseViewsDir(join(__dirname, '..', 'views'));\nhbs.registerPartials(join(__dirname, '..', 'views/layouts'));\nhbsUtils(hbs).registerWatchedPartials(join(__dirname, '..', 'views/layouts'));\napp.setViewEngine('hbs');\n…\n",
      page_no: 20,
    },
    {
      id: 37,
      bookId: 33,
      content:
        'We import the hbs  library as a hbs  object and the hbs-utils  library as a hbsUtils object. We instruct hbs  that the\nviews/layouts  folder will be used for storing Handlebars Partials using the registerPartials  method. We then tell\nhbsUtils  to watch the views/layouts  folder for changes using the registerWatchedPartials  method.\nCreating app.hbs\nTo get started with Bootstrap and the hbs layout, we first create a folder called layouts  under the views  folder. We\nthen use the Bootstrap starter template to create our layout (see Fig. 6-2). The Bootstrap starter template can be\nfound here: https://getbootstrap.com/docs/5.1/getting-started/introduction/.\nFigure 6-2. Bootstrap starter template.\nIn views/layouts , create a new file called app.hbs  and fill it with the following code.\nAdd Entire Code\n<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1" />\n  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />\n  <title>{{#if title}}{{ title }}{{else}}Online Store{{/if}}</title>\n</head>\n<body>\n  <!-- header -->\n  <nav class="navbar navbar-expand-lg navbar-dark bg-secondary py-4">\n    <div class="container">\n      <a class="navbar-brand" href="#">Online Store</a>\n      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"\n        aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">\n        <span class="navbar-toggler-icon"></span>\n      </button>\n      <div class="collapse navbar-collapse" id="navbarNavAltMarkup">\n        <div class="navbar-nav ms-auto">\n          <a class="nav-link active" href="#">Home</a>\n          <a class="nav-link active" href="#">About</a>\n        </div>\n      </div>\n    </div>\n  </nav>\n  <header class="masthead bg-primary text-white text-center py-4">\n    <div class="container d-flex align-items-center flex-column">\n      <h2>{{#if subtitle}}{{ subtitle }}{{else}}A Nest Online Store{{/if}}</h2>\n    </div>\n  </header>\n  <!-- header -->\n  <div class="container my-4">\n    {{> content}}\n  </div>\n  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous">\n  </script>\n</body>\n</html>\nThe above code is based on the Bootstrap starter template code and the Bootstrap Navbar\n(https://getbootstrap.com/docs/5.1/components/navbar/). We modified the base code including links in the header\n( Home  and About ). The stater template includes a Bootstrap CSS file ( bootstrap.min.css ), and a Bootstrap JS\nfile ( bootstrap.bundle.min.js ). We included three objects title , subtitle , and content .\n',
      page_no: 21,
    },
    {
      id: 38,
      bookId: 33,
      content:
        'The  title  and subtitle  objects are wrapped by an if condition. The  if  hbs helper can be used to conditionally\nrender a block. For example, if title  object is defined, it will render the title value. Otherwise, it renders the\ncontent of the  else  block (in this case “Online Store” text).\nFinally, {{> content}}  defines a partial call. In that specific location, we will inject other views code.\nModifying index.hbs\nDelete all the existing code in views/index.hbs  and fill it with the following code.\nReplace Entire Code\n{{#> app}}\n  {{#*inline "content"}}\n    <div class="text-center">\n      Welcome to the application\n    </div>\n  {{/inline}}\n{{/app}}\nThe  index  view invokes and renders the app  layout with the use of the app  block {{#> app}}…{{/app}} . We\ndefine an inline partial called content , which is rendered inside the app  layout in the {{> content}} line. In\nsummary, the index view injects an HTML div with a welcome message inside the {{> content}} line of the  app\nlayout.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nOpen the browser to http://localhost:3000/ and you will see the application with the new layout (see Fig. 6-3). If\nyou reduce the browser window width, you will see a responsive navbar (thanks to the bootstrap starter template,\nnavbar, and the inclusion of the bootstrap files, see Fig. 6-4). Note: sometimes, you need to stop and start the server\nto see the changes due to the inclusion of new libraries in the project.\nFigure 6-3. Application home page with layout.\nFigure 6-4. Application home page with reduced browser window width.\n',
      page_no: 22,
    },
    {
      id: 39,
      bookId: 33,
      content:
        'Adding custom CSS styles and a Footer\nLet’s make our app interface more professional. We will include a custom CSS file and a footer in our layout.\nCustom style (app.css)\nCreate a folder called public  under the root project folder. Then, create a subfolder called css  under the public/\nfolder. Then, in public/css  create a new file called app.css  and fill it with the following:\nAdd Entire Code\n.bg-secondary {\n  background-color: #2c3e50 !important;\n}\n.copyright {\n  background-color: #1a252f;\n}\n.bg-primary {\n  background-color: #1abc9c !important;\n}\nnav {\n  font-weight: 700;\n}\n.img-card {\n  height: 18vw;\n  object-fit: cover;\n}\nWe have some custom CSS styles in the previous file. We override some Bootstrap elements with our own values\nand colors.\nThis CSS file is available for public access. If you have the server running you can access it from:\nhttp://localhost:3000/css/app.css. This is because we told Express that the public  folder will be used for storing\nstatic assets. So, all files inside the public  folder can be accessed from our server link.\nModifying app.hbs\nFinally, in views/layouts/app.hbs , make the following changes in bold to include the previous CSS file and create\nthe footer section.\nModify Bold Code\n<!doctype html>\n<html lang="en">\n<head>\n...\n<link href="/css/app.css" rel="stylesheet" />\n<title>{{#if title}}{{ title }}{{else}}Online Store{{/if}}</title>\n</head>\n<body>\n…\n<!-- footer -->\n<div class="copyright py-4 text-center text-white">\n<div class="container">\n<small>\nCopyright - <a class="text-reset fw-bold text-decoration-none" target="_blank"\nhref="https://twitter.com/danielgarax">\nDaniel Correa\n</a> - <a class="text-reset fw-bold text-decoration-none" target="_blank"\nhref="https://twitter.com/greglim81">\nGreg Lim\n</a>\n</small>\n</div>\n</div>\n<!-- footer -->\n  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous">\n  </script>\n</body>\n</html>\nWe include our custom CSS file ( css/app.css ), and created a footer section with this book’s author names and links\nto their Twitter accounts.\n',
      page_no: 23,
    },
    {
      id: 40,
      bookId: 33,
      content:
        "Running the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nYou will see our index page, with the refined layout (see Fig. 6-5). It looks more professional (at least for us). This\ndesign was inspired by a free Bootstrap template called Freelancer. You can find more information about this\ntemplate here: https://startbootstrap.com/theme/freelancer.\nFigure 6-5. Application home page with refined layout.\nWe will refine the index page and create an about page in the next chapter.\n",
      page_no: 24,
    },
    {
      id: 41,
      bookId: 33,
      content:
        'Chapter 07 – Index and About Pages\nIndex view\nThe home page currently just displays a welcome message. Let’s modify the index view to improve the home page\ndesign. In views/index.hbs , make the following changes in bold.\nModify Bold Code\n{{#> app}}\n{{#*inline "content"}}\n<div class="text-center">\nWelcome to the application\n</div>\n<div class="row">\n<div class="col-md-6 col-lg-4 mb-2">\n<img src="/img/game.png" class="img-fluid rounded">\n</div>\n<div class="col-md-6 col-lg-4 mb-2">\n<img src="/img/safe.png" class="img-fluid rounded">\n</div>\n<div class="col-md-6 col-lg-4 mb-2">\n<img src="/img/submarine.png" class="img-fluid rounded">\n</div>\n</div>\n{{/inline}}\n{{/app}}\nWe define some divisions to display some images. We need to download these images and store them in our\npublic  folder. First, in public  folder, create a subfolder called img . Then, download the following three images\nfrom this link https://github.com/PracticalBooks/Practical-Nest/tree/main/Chapter07/online-store/public/img and\nstore them inside the public/img  folder (see Fig. 7-1).\nFigure 7-1. Project structure after storing the images.\nAbout view\nLet’s create the About view. In views , create a new file called about.hbs , and fill it with the following code.\nAdd Entire Code\n{{#> app}}\n{{#*inline "content"}}\n<div class="container">\n<div class="row">\n<div class="col-lg-4 ms-auto">\n<p class="lead">{{ viewData.description }}</p>\n</div>\n<div class="col-lg-4 me-auto">\n<p class="lead">{{ viewData.author }}</p>\n</div>\n</div>\n</div>\n{{/inline}}\n{{/app}}\nWe have a simple view that displays a description of the application and some information about the author. We\nwill pass the viewData.description  and viewData.author  data from a controller to this view later. Remember that\nhbs allows curly braces to display data passed to the view.\nIntroducing Nest Controllers\n',
      page_no: 25,
    },
    {
      id: 42,
      bookId: 33,
      content:
        'Controllers are responsible for handling incoming requests and returning responses to the client. Controllers can\ngroup related request handling logic into a single class. For example, a UserController  class might handle all\nincoming requests related to users, including showing, creating, updating, and deleting users.\nNest Controllers are classes with decorators. Decorators associate these classes with required metadata and enable\nNest to create a routing map (tie requests to the corresponding controllers). More information about Nest\nControllers can be found here: https://docs.nestjs.com/controllers.\nLinking the ‘About’ Page\nLet’s modify our AppController  to define a route for our ‘about’ page. In src/app.controller.ts , make the\nfollowing changes in bold.\nModify Bold Code\n…\n@Controller()\nexport class AppController {\n@Get("/")\n@Render(\'index\')\nindex() {\nreturn {\ntitle: "Home Page - Online Store"\n};\n}\n@Get("/about")\n@Render(\'about\')\nabout() {\nlet viewData = [];\nviewData["description"] = "This is an about page ...";\nviewData["author"] = "Developed by: Your Name";\nlet data1 = \'About us - Online Store\';\nreturn {\ntitle: data1,\nsubtitle: "About us",\nviewData: viewData\n};\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\n@Get("/")\n@Render(\'index\')\nindex() {\nreturn {\ntitle: "Home Page - Online Store"\n};\n}\nWe included a return section in the  index  method.  return  passes a JavaScript object (which defines a  title  data\nthat contains a text) to the index  view and app  layout. This enables the application to show the “Home Page -\nOnline Store” text over the browser tab.\nAnalyze Code\n@Get("/about")\n@Render(\'about\')\nabout() {\nlet viewData = [];\nviewData["description"] = "This is an about page ...";\nviewData["author"] = "Developed by: Your Name";\nlet data1 = \'About us - Online Store\';\nreturn {\ntitle: data1,\nsubtitle: "About us",\nviewData: viewData\n};\n}\nWe have the about  method connected to the (“/about”) route. This connection is established by the @Get\ndecorator. about method defines an associative array called  viewData . It also defines a variable called data1\nwhich contains the title of the page. Then, we define the values for the description  and author  keys of the\n',
      page_no: 26,
    },
    {
      id: 43,
      bookId: 33,
      content:
        "viewData  array. We pass the title , subtitle , and viewData  to the about view and app  layout. The  about  view\nwill show the viewData.description  and viewData.author  values, and the app  layout will show the title  and\nsubtitle  values.\nRecap, when a user goes to the “/” route, the index  view will be displayed (rendered in the AppController index\nmethod). Likewise, when a user goes to the “/about” route, the about  view will be displayed (rendered in the\nAppController about  method).\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nGo to the “/” route, and you will see the new home page (see Fig. 7-2). Then, go to the “/about” route, and you will\nsee the about page (see Fig. 7-3).\nFigure 7-2. Online Store – Home page.\nFigure 7-3. Online Store – About page.\nWe created a couple of Nest views, a Nest Controller, and defined a couple of routes. However, we have not linked\nthe navbar menu to the new routes. We have also purposely introduced some mistakes when defining the previous\nelements. Why? This is because we want to illustrate the concept of clean code. In the next chapter, we will refactor\nthese elements and apply some good strategies about clean code in controllers and views.\n",
      page_no: 27,
    },
    {
      id: 44,
      bookId: 33,
      content:
        'Chapter 08 – Refactoring Index and About Pages\nThe code in the previous chapter can be further cleaned and improved. This is because, we have not defined rules\nfor coding any of the elements. We will see how to refactor the code to make it cleaner and more maintainable. We\nwill also provide general tips for handling controllers and views. Keep in mind that most of the principles presented\nin this chapter apply not only to a Nest project but can be applied in other MVC frameworks (such as Django,\nSpring, Laravel, Express, and more).\nRefactoring controllers\nPrevious controller\nThe previous chapter showed a controller with two methods. Let’s analyze the about  method.\nAnalyze Code\n@Get("/about")\n@Render(\'about\')\nabout() {\nlet viewData = [];\nviewData["description"] = "This is an about page ...";\nviewData["author"] = "Developed by: Your Name";\nlet data1 = \'About us - Online Store\';\nreturn {\ntitle: data1,\nsubtitle: "About us",\nviewData: viewData\n};\n}\nHere we have three problems.\n• Variable naming is a mess. Using names such as data1 is horrible; it does not say anything. Instead of that,\nwe can use title .\n• We have three elements defined in the return JavaScript object ( title , subtitle , and viewData ). Imagine if we\nhave 20 variables to pass to the view. We do not have consistency. We send some variables to the view one by\none, and we also send some variables grouped in an array. We will use the viewData  variable to pass all the\ninformation to the view within a single array variable. This will be our preferred strategy as we will see it next.\n• Finally, we have a blank line before the ending of the curly brackets, and we define some texts with single\nquotes (check data1 ) and others with double quotes (check subtitle ). We need to define a consistent coding\nstyle guide. This one will be solved in the next chapter.\nQuick discussion: Let’s see the importance of variable naming with two quotes from the (2019 -\nThomas, D., & Hunt, A. - The Pragmatic Programmer: your journey to mastery) book. “The\nbeginning of wisdom is the ability to call things by their right names. - Confucius.” - “Why is\nnaming important? Because good names make code easier to read, and you have to read it to\nchange it.”\nNext, let’s refactor the controller.\nNew controller\nLet’s refactor our controller. In src/app.controller.ts , make the following changes in bold (replace the content of\nthe  index  and about  methods).\nModify Bold Code\n…\n@Controller()\nexport class AppController {\n@Get("/")\n@Render(\'index\')\nindex() {\nlet viewData = [];\nviewData[\'title\'] = \'Home Page - Online Store\';\nreturn {\nviewData: viewData\n};\n}\n@Get("/about")\n@Render(\'about\')\n',
      page_no: 28,
    },
    {
      id: 45,
      bookId: 33,
      content:
        "about() {\nconst viewData = [];\nviewData['title'] = 'About us - Online Store';\nviewData['subtitle'] = \"About us\";\nviewData['description'] = \"This is an about page ...\";\nviewData['author'] = 'Developed by: Your Name';\nreturn {\nviewData: viewData,\n};\n}\n}\nNow that we use the single variable strategy both methods are consistent. The return sends only viewData . With\nthis approach, it does not matter if we pass one variable to the view or dozens. In both cases, we pass the associative\narray.\nCheck that we have some differences in the coding style (spacing, variable definition, and use of single quotes vs\ndouble quotes). Those mistakes were introduced on purpose, but we will fix in the next chapter.\nRefactoring views\nThe previous chapter showed two views that display data a little differently. The views/about.hbs view will not be\nchanged since it displays the data using the viewData  strategy. However, we will need to modify the\nviews/layouts/app.hbs view to match the single variable strategy previously defined.\nLet’s refactor our app  view. In views/layouts/app.hbs , make the following changes in bold.\nModify Bold Code\n...\n<head>\n...\n<link href=\"/css/app.css\" rel=\"stylesheet\" />\n<title>{{#if viewData.title}}{{ viewData.title }}{{else}}Online Store{{/if}}</title>\n</head>\n…\n<header class=\"masthead bg-primary text-white text-center py-4\">\n<div class=\"container d-flex align-items-center flex-column\">\n<h2>{{#if viewData.subtitle}}{{ viewData.subtitle }}{{else}}A Nest Online Store{{/if}}</h2>\n</div>\n</header>\n…\nAs you can see, we now access the data through the single viewData associative array. We will use this strategy\nacross the entire application, making our views more consistent.\nTIP: As a software developer, a good strategy is to create a document with architectural rules\nand share that document with your team (if you have one). You can make that document in the\nproject repository wiki (if you have one). Encourage all the members to read that document. A\nfirst rule that you can include in that document could be: “controllers should only pass an\nassociative array called viewData to the views”. These simple rules will save you a lot of time\nand a lot of headaches; believe us, Daniel always creates a document like that for all his projects,\nand he encourages his students to do it in their projects.\nQuick discussion: Some of the previous data (such as the description  and author ) can also be\nplaced directly over the about  view. We mean, you do not need to define some of those texts as\nvariables in the controller and send them to the view. Instead, you can place the text directly in\nthe views. We did it that way to illustrate and explain some Nest elements. There is even a better\noption that is out of this book’s scope. That option is called Internationalization or i18n. In i18n,\nyou move away those texts from controllers and views and place them in the src/i18n  folder.\nI18n allows you even to retrieve strings in various languages to create a multi-language\napplication. It is not difficult to implement; you can use this library to get more info about it\nhttps://www.npmjs.com/package/nestjs-i18n, search in Google, or let us know if you need a\ngood example (use the discussion zone of the book repository).\nUpdating links in Header\nNow that we have the proper controller and views, let’s include the links in the header. In views/layouts/app.hbs ,\nmake the following changes in bold.\nModify Bold Code\n",
      page_no: 29,
    },
    {
      id: 46,
      bookId: 33,
      content:
        '<!doctype html>\n...\n<body>\n<!-- header -->\n<nav class="navbar navbar-expand-lg navbar-dark bg-secondary py-4">\n<div class="container">\n<a class="navbar-brand" href="/">Online Store</a>\n      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"\naria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">\n<span class="navbar-toggler-icon"></span>\n</button>\n<div class="collapse navbar-collapse" id="navbarNavAltMarkup">\n<div class="navbar-nav ms-auto">\n<a class="nav-link active" href="/">Home</a>\n<a class="nav-link active" href="/about">About</a>\n</div>\n</div>\n</div>\n</nav>\n...\nWe declared the corresponding routes for each link.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow, you can navigate between the Home  page and the About  page by using the links in the navigation bar (see\nFig. 8-1).\nFigure 8-1. Online Store – About page.\nNote: You can find the application code at the GitHub repository in https://github.com/PracticalBooks/Practical-\nNest.\n',
      page_no: 30,
    },
    {
      id: 47,
      bookId: 33,
      content:
        'Chapter 09 – Use of a Coding Standard\nA coding standard is a set of rules and agreements used when writing source code in a particular programming\nlanguage. Using a coding standard provides some advantages, such as:\n•It gives a uniform appearance to the codes written by different programmers.\n•It improves the readability and maintainability of the code and reduces complexity.\n•It helps in code reuse and helps to detect errors easily.\n•It promotes good programming practices and increases the efficiency of the programmers.\nMany frameworks come with tools which automate code checking and fixing against a set of predefined rules. For\nexample, Nest comes with ESLint and Prettier out of the box. In this book, we will use ESLint, so let’s learn more\nabout it.\nIntroducing ESLint\nESLint is a JavaScript linter that enables you to enforce a set of style, formatting, and coding standards for your\ncodebase. It looks at your code and tells you when you\'re not following the standard that you set in place\n(https://eslint.org/).\nBy default, ESLint does not support TypeScript (the language we use to create our controllers and other files).\nHowever, Nest includes typescript-eslint/eslint-plugin  and typescript-eslint/parser  dependencies which enables\nESLint to support TypeScript.\nNest defines the ESLint configuration and rules in the .eslintrc.js file. Therefore, Nest defines a script to execute\nESLint. That script ( lint ) can be found in the scripts section of the package.json  file. Let’s analyze it.\nAnalyze Code\n"lint": "eslint \\ "{src,apps,libs,test}/**/*.ts \\ " --fix",\nWhen we run npm run lint , the above script is executed. This script executes ESLint and checks and fixes all the\nTypeScript files inside the src ,  apps , libs , and test folders.\nRunning ESLint\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run lint\nThis executes ESLint based on the custom configuration defined in .eslintrc.js  (see Fig. 9-1). You will see changes\nin some of your TypeScript files (such as the src/app.controller.ts ). If you open that file, you will see that the\nstrange spaces have disappeared. All texts are defined with single quotes, and variables are defined with “cons”\ninstead of “let” when it applies.\nFigure 9-1. Running ESLint.\nFinal remark\nThe current ESLint configuration only checks and fixes TypeScript files. So, if you want to format Handlebars files,\nyou can use a third-party library (such as eslint-plugin-hbs ) or use a Visual Studio Code formatter such as “HTML\nLanguage Features”.\nTIP: There is a good story about “The Broken Window Theory” described in the (2019 -\nThomas, D., & Hunt, A. - The Pragmatic Programmer: your journey to mastery) book. You can\nsearch it in Google. From that story, we want to highlight the next tip. Don’t leave “broken\nwindows” (e.g., bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon\nas it is discovered. The previous three chapters showed many broken windows which fortunately\nwere fixed.\nTIP: Always use a coding standard tool, formatter, static code analysis tool, or even a\ncombination of them in your projects. It will save you a lot of time and improve the code quality.\nIn addition, you will find linters available for most programming languages. Besides, include a\n',
      page_no: 31,
    },
    {
      id: 48,
      bookId: 33,
      content:
        "rule in your architectural rules document mentioning that all code changes should be previously\nverified using these tools. You can even automate this process (with a pipeline or CI/CD\nstrategy). However, this is out of the scope of this book.\n",
      page_no: 32,
    },
    {
      id: 49,
      bookId: 33,
      content:
        "Chapter 10 – List Products with Dummy Data\nIn this chapter, we will implement functionality to list products and to be able to click those products and display\ntheir data in a separate section.\nListing products\nLet’s start by creating a new controller to implement the list products functionality.\nProducts controller\nIn src/ , create a new file called products.controller.ts , and fill it with the following code.\nAdd Entire Code\nimport { Controller, Get, Render } from '@nestjs/common';\n@Controller('/products')\nexport class ProductsController {\nstatic products = [\n{\nid: '1',\nname: 'TV',\ndescription: 'Best tv',\nimage: 'game.png',\nprice: '1000',\n},\n{\nid: '2',\nname: 'iPhone',\ndescription: 'Best iPhone',\nimage: 'safe.png',\nprice: '999',\n},\n{\nid: '3',\nname: 'Chromecast',\ndescription: 'Best Chromecast',\nimage: 'submarine.png',\nprice: '30',\n},\n{\nid: '4',\nname: 'Glasses',\ndescription: 'Best Glasses',\nimage: 'game.png',\nprice: '100',\n},\n];\n@Get('/')\n@Render('products/index')\nindex() {\nconst viewData = [];\nviewData['title'] = 'Products - Online Store';\nviewData['subtitle'] = 'List of products';\nviewData['products'] = ProductsController.products;\nreturn {\nviewData: viewData,\n};\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\n@Controller('/products')\nWe use the @Controller  decorator and pass in a path prefix (“/products”). This allows us to group a set of related\nroutes and minimize repetitive code. All methods defined in this controller will automatically include the\n“/products” path prefix.\nAnalyze Code\nstatic products = [\n{\nid: '1',\nname: 'TV',\ndescription: 'Best tv',\n",
      page_no: 33,
    },
    {
      id: 50,
      bookId: 33,
      content:
        "image: 'game.png',\nprice: '1000',\n},\n…\nproducts  is an array that contains a set of products with its data. In the array index 0, we have the product with id=1\n(the “TV”). We have four dummy products. Currently, they are stored as a static attribute of the\nProductsController  class. We will later retrieve product data from a MySQL database in upcoming chapters.\nAnalyze Code\n@Get('/')\n@Render('products/index')\nindex() {\nconst viewData = [];\nviewData['title'] = 'Products - Online Store';\nviewData['subtitle'] = 'List of products';\nviewData['products'] = ProductsController.products;\nreturn {\nviewData: viewData,\n};\n}\nThe index method gets the array of products and sends them to the products/index  view to be displayed.\nProducts index view\nIn views/ , create a subfolder called products . Then, in views/products , create a new file called index.hbs , and\nfill it with the following code.\nAdd Entire Code\n{{#> app}}\n{{#*inline \"content\"}}\n<div class=\"row\">\n{{#each viewData.products}}\n<div class=\"col-md-4 col-lg-3 mb-2\">\n<div class=\"card\">\n<img src=\"/img/{{image}}\" class=\"card-img-top img-card\">\n<div class=\"card-body text-center\">\n<a href=\"/products/{{id}}\" class=\"btn bg-primary text-white\">{{name}}</a>\n</div>\n</div>\n</div>\n{{/each}}\n</div>\n{{/inline}}\n{{/app}}\nThe important part of the previous code is the {{#each viewData.products}} . each  is a hbs built-in helper which\nallows us to iterate over a list. We iterate through each product and display the product image and name. More\ninformation about hbs built-in helpers can be found here: https://handlebarsjs.com/guide/builtin-helpers.html.\nAnalyze Code\n<a href=\"/products/{{id}}\" class=\"btn bg-primary text-white\">{{name}}</a>\nFinally, we put a link to the product name. The link will route to a new ProductsController method (which will be\ndefined later) and it requires a parameter to be sent. In this case, we send the product id of the current iterated\nproduct.\nShowing a specific product\nProducts controller\nIn src/products.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Param } from '@nestjs/common';\n@Controller('/products')\nexport class ProductsController {\n…\n@Get('/')\n@Render('products/index')\nindex() {\n…\n}\n@Get('/:id')\n",
      page_no: 34,
    },
    {
      id: 51,
      bookId: 33,
      content:
        '@Render(\'products/show\')\nshow(@Param() params) {\nconst product = ProductsController.products[params.id - 1];\nconst viewData = [];\nviewData[\'title\'] = product.name + \' - Online Store\';\nviewData[\'subtitle\'] = product.name + \' - Product Information\';\nviewData[\'product\'] = product;\nreturn {\nviewData: viewData,\n};\n}\n}\nFirst, we import the Param  decorator. This decorator will be used to collect route parameters later.\nWe link the show  method to the (“/:id”) route. Because we include the ProductsController  path prefix, the\ncomplete route is (“products/:id”). “/products/:id” takes a parameter called id . This parameter is the product id  to\nidentify which product data to show. For example, if we access “/products/1” URL, the application will display the\ndata of the product with id=1.\nThe show  method contains a params  argument decorated with @Param() . @Param()  makes the route\nparameters available as properties inside the method. We can access the id  parameter by referencing params.id .\nThen, we extract the corresponding product (from the ProductsController.products  array) based on the params.id\nvalue. We subtract one unit since we stored the product with id=1 in the ProductsController.products  array index\n0, the product with id=2 in the ProductsController.products  array index 1, and so on. We then send the product\ndata to the products/show  view.\nProduct show view\nIn views/products , create a new file called show.hbs , and fill it with the following code.\nAdd Entire Code\n{{#> app}}\n{{#*inline "content"}}\n{{#with viewData.product}}\n<div class="card mb-3">\n<div class="row g-0">\n<div class="col-md-4">\n<img src="/img/{{image}}" class="img-fluid rounded-start">\n</div>\n<div class="col-md-8">\n<div class="card-body">\n<h5 class="card-title">\n{{name}} (${{price}})\n</h5>\n<p class="card-text">{{description}}</p>\n<p class="card-text"><small class="text-muted">Add to Cart</small></p>\n</div>\n</div>\n</div>\n</div>\n{{/with}}\n{{/inline}}\n{{/app}}\nThe with hbs helper dives into the viewData.product  object and gives us direct access to the product\nproperties( name , description ,  image , and price ). We show the product  image , name , price , and\ndescription  in the markup. Remember, we are using dummy data. This will change in upcoming chapters.\nTIP: In the last examples, we have defined a structure to store our controllers, controllers’\nmethods, routes, and views. For example, the \nproducts/  route, is linked to the\nProductsController index  method, which displays the products/index  view. Try to use this\nstrategy across the entire project as it facilitates finding the views of the corresponding\ncontrollers’ methods and vice versa.\nIntroducing Nest Modules\nModules are classes annotated with a @Module()  decorator. The @Module()  decorator provides metadata that\nNest uses to organize the application structure. Each application has at least one module, a root module. The root\nmodule is the starting point Nest uses to build the application. In our case, src/app.module.ts  is our root module.\nThe @Module()  decorator allows defining a set of properties:\n• controllers: the set of controllers in this module to be instantiated.\n',
      page_no: 35,
    },
    {
      id: 52,
      bookId: 33,
      content:
        '• providers: the providers that will be instantiated by the Nest injector and shared at least across this module\n(we will use providers in Chapter 14).\n• imports: the list of imported modules required in this module (we will use imports in Chapter 12).\n• exports: the subset of providers provided by this module and available to other modules (we will use exports\nin Chapter 17).\nYou can design small Nest applications which consist of only one module. However, for complex applications, it is\nrecommended to employ multiple modules. We will split our Online Store application into four modules (detailed\nlater).\nRegistering ProductsController in AppModule\nLet’s register the ProductsController  in our  AppModule . In src/app.module.ts , make the following changes in\nbold.\nModify Bold Code\nimport { Module } from \'@nestjs/common\';\nimport { AppController } from \'./app.controller\';\nimport { ProductsController } from \'./products.controller\';\n@Module({\nimports: [],\ncontrollers: [AppController, ProductsController],\n})\nexport class AppModule {}\nWe import our newly created ProductsController , and register it in the AppModule controllers  property. This\nway, all the ProductsController  routes will be available for access from the browser.\nUpdating links in Header\nNow, let’s include the products links in the header. In views/layouts/app.hbs , make the following changes in bold.\nModify Bold Code\n<!doctype html>\n...\n<div class="navbar-nav ms-auto">\n<a class="nav-link active" href="/">Home</a>\n<a class="nav-link active" href="/products">Products</a>\n<a class="nav-link active" href="/about">About</a>\n</div>\n...\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow, you can go to the Products  page (see Fig. 10-1) and navigate to a specific product (see Fig. 10-2).\n',
      page_no: 36,
    },
    {
      id: 53,
      bookId: 33,
      content:
        "Figure 10-1. Online Store – Products page.\nFigure 10-2. Online Store – iPhone product page.\n",
      page_no: 37,
    },
    {
      id: 54,
      bookId: 33,
      content:
        "Chapter 11 – Configuration of MySQL Database\nIntroduction to MySQL\nMySQL is the most popular Open-Source SQL database management system developed, distributed, and supported\nby Oracle.\n• MySQL is a database management system. A database is a structured collection of data. It may be anything\nfrom a simple shopping list to a picture gallery or the vast amounts of information in a corporate network. To\nadd, access, and process data stored in a computer database, you need a database management system such as\nMySQL.\n• MySQL databases are relational. A relational database stores data in separate tables rather than putting all\nthe data in one big storeroom. The database structures are organized into physical files optimized for speed.\nMySQL provides a logical model, with objects such as databases, tables, views, rows, and columns to offer a\nflexible programming environment.\nMySQL tables\nA table is used to organize data in the form of rows and columns. It is used for both storing and displaying records\nin a structured format. It is like worksheets in a spreadsheet application.  The columns specify the data type,\nwhereas the rows contain the actual data. Below is how you could imagine a MySQL table (see Fig. 11-1).\nFigure 11-1. Product table.\nMySQL installation\nThere are several different ways of installing MySQL. In this book, we will install MySQL and a MySQL\nadministration tool called phpMyAdmin. Both tools can be found in a development environment called XAMPP.\nSo, let’s install XAMPP.\nXAMPP\nXAMPP is a popular PHP development environment. XAMPP is a free, easy to install Apache distribution\ncontaining MySQL, PHP, and Perl. XAMPP also includes phpMyAdmin. If you don’t have XAMPP installed, go to\nhttps://www.apachefriends.org/download.html, download and install it.\nConfiguring our database\nExecute XAMPP, start the Apache Module, then start  MySQL module, and click the MySQL Admin button (of\nthe MySQL module). This takes us to the phpMyAdmin application (see Fig. 11-2).\nFigure 11-2. Starting MySQL module in XAMPP.\nNote: If you are using WAMP or another similar application, the phpMyAdmin application can be commonly\naccessed through the following route: http://localhost/phpmyadmin/.\nIn the phpMyAdmin application enter your username and password. Default values are “root” (for the username),\n",
      page_no: 38,
    },
    {
      id: 55,
      bookId: 33,
      content:
        "and an empty password (see Fig. 11-3).\nFigure 11-3. XAMPP phpMyAdmin application.\nOnce logged in to phpMyAdmin, click the Databases  tab. Enter the database name “online_store”, and click\nCreate  (see Fig. 11-4).\nFigure 11-4. Database creation.\nWe will use the username, password, and database name in the following chapter.\n",
      page_no: 39,
    },
    {
      id: 56,
      bookId: 33,
      content:
        'Chapter 12 – Configuration of TypeORM\nNest Databases\nNest is database agnostic, allowing you to integrate with any SQL or NoSQL database easily. Nest provides tight\nintegration with TypeORM, Sequelize, and Mongoose through the @nestjs/typeorm, @nestjs/sequelize, and\n@nestjs/mongoose packages respectively (https://docs.nestjs.com/techniques/database).\nNest suggests using TypeORM because it\'s the most mature Object Relational Mapper (ORM) available for\nTypeScript. Since it\'s written in TypeScript, it integrates well with the Nest framework.\nIntroduction to TypeORM\nTypeORM is an ORM that can run in NodeJS, Browser, Cordova, PhoneGap, Ionic, React Native, NativeScript,\nExpo, and Electron platforms and can be used with TypeScript and JavaScript. Its goal is to help you develop any\napplication that uses databases, from small applications with a few tables to large scale enterprise applications with\nmultiple databases.\nTypeORM provides support for many relational databases, such as PostgreSQL, MySQL, Oracle, Microsoft SQL\nServer, SQLite, and even NoSQL databases like MongoDB.\nNest TypeORM integration\nTypeORM installation\nTo connect our Online Store application with our MySQL database, we need to install and integrate TypeORM. In\nthe Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm install --save @nestjs/typeorm typeorm mysql2\nThis installs TypeORM and other required libraries to work with MySQL.\nTypeORM config file\nNow, let’s define the configuration file (where we will place our database credentials). In the project root directory,\ncreate a new file called ormconfig.json , and fill it with the following code.\nAdd Entire Code\n{\n    "type": "mysql",\n    "host": "localhost",\n    "port": 3306,\n    "username": "root",\n    "password": "",\n    "database": "online_store",\n    "entities": ["dist/**/*.entity{.ts,.js}"],\n    "synchronize": true\n}\nWe used the username, password, and database name from the previous chapter.\nTypeORM import\nWe import the TypeORM in our AppModule . In src/app.module.ts , make the following changes in bold.\nModify Bold Code\nimport { Module } from \'@nestjs/common\';\nimport { AppController } from \'./app.controller\';\nimport { ProductsController } from \'./products.controller\';\nimport { TypeOrmModule } from \'@nestjs/typeorm\';\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\n],\ncontrollers: [AppController, ProductsController],\n})\nexport class AppModule {}\nWe imported the TypeOrmModule and register it in the AppModule imports  property by invoking the\nTypeOrmModule.forRoot()  method. Remember that the @Module imports  property is used to register other\n',
      page_no: 40,
    },
    {
      id: 57,
      bookId: 33,
      content:
        "modules required by the current module. In this case, our root module ( AppModule ) requires TypeOrmModule .\nThe TypeOrmModule.forRoot()  method configures the TypeORM library. It receives an optional parameter with\nthe configuration values (i.e., database credentials). If no parameter is passed, the Nest application will try to load\normconfig.json  file and pass the information to the TypeORM library.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nYou should see the application running normally (see Fig. 12-1). This means that the integration was successful,\nand the application is now connected to the database. If you get an error like “ERROR [TypeOrmModule] Unable\nto connect to the database”, please check that MySQL is running and the database credentials are correct.\nFigure 12-1. TypeORM proper configured.\n",
      page_no: 41,
    },
    {
      id: 58,
      bookId: 33,
      content:
        "Chapter 13 – Product Entity\nIntroduction to TypeORM Entities\nAn entity is a class that maps to a database ‘table’ (or ‘collection’ in MongoDB). You can create an entity by\ndefining a new class and mark it with @Entity()  decorator. More information about TypeORM entities can be\nfound here: https://typeorm.io/#/entities. Let’s create an Entity to understand it in a practical approach.\nCreating Product Entity\nFirst, in src  folder, create a subfolder called models . In src/models , create a new file product.entity.ts , and fill it\nwith the following code.\nAdd Entire Code\nimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n@Entity()\nexport class Product {\n@PrimaryGeneratedColumn()\nid: number;\n@Column()\nname: string;\n@Column()\ndescription: string;\n@Column()\nimage: string;\n@Column()\nprice: number;\n}\nTypeORM entities consist of columns and relations. In the above code, we define a Product  entity (which will\nbecome into a product table) with five attributes ( id , name ,  description , image , and price ). By specifying the\n@Column  decorator, all these attributes will become columns of the product table.\nTypeORM requires that each entity have a primary column (or ObjectId column if using MongoDB). In our case,\nthe Product entity primary column is id . The @PrimaryGeneratedColumn()  creates a primary column that\nautomatically generates an auto-increment value.\nQuick discussion: We are storing our entities inside the src/models  folder. We named that\nfolder as models  to keep it consistent with our MVC architecture. However, not all Nest\napplications store their models (or entities) inside a models  folder. The official documentation\nrecommends storing the models near their domain, in the corresponding ‘module’ directory.\nCurrently, we only have one module (the AppModule ). Later, we will create four modules.\nMost of those modules will use most of the entities that we will define. Thus, we decided not to\nplace the entities in specific a ‘module’ directory but under a “global” src/models  folder.\nSynchronizing the database\nWe have created a Product entity. Our TypeORM config file ( ormconfig.json ) contains an option called\nsynchronize  with a value of true . It also contains an option called entities  that specifies the directories where\nTypeORM should search for entities. The value is dist/**/*.entity{.ts,.js} . The value is a regular expression which\nsearches for all files (in the dist  folder) that contain .entity in their filenames. Remember that the dist  folder\ncontains the compiled production version of the source code.\nWhy are the synchronize  and entities  options important? Because, once we start the server, Nest generates the\ndist  folder, runs the code, and executes TypeORM. Since synchronize  option is true , TypeORM searches for new\nentities or changes in those entities and automatically creates the corresponding tables based on those entities. Be\ncareful to note that setting synchronize  to true  shouldn't be used in a production environment, otherwise you can\nmistakenly lose production data.\nLet’s synchronize our database. First, stop the server. Then, In the Terminal, go to the project directory, and\nexecute the following:\n",
      page_no: 42,
    },
    {
      id: 59,
      bookId: 33,
      content:
        "Execute in Terminal\nnpm run start:dev\nNow, you can see the new product  table in your online_store  database (see Fig. 13-1).\nFigure 13-1. New product table – phpMyAdmin.\nNote: if you create a new entity or modify an existing one, you should repeat the previous process to apply the\nchanges over the database (stop and start the server).\nInserting products\nLet’s insert four products into our database. For now, we will insert it manually (through SQL queries). Later, we\nwill insert products through a form in an upcoming chapter.\nIn phpMyAdmin, click the online_store  database, click the SQL  tab, paste the following SQL queries, and click\ngo (see Fig. 13-2).\nExecute in Database\nINSERT INTO product (name, description, image, price) VALUES ('TV', 'Best TV', 'game.png', '1000');\nINSERT INTO product (name, description, image, price) VALUES ('iPhone', 'Best iPhone', 'safe.png', '999');\nINSERT INTO product (name, description, image, price) VALUES ('Chromecast', 'Best Chromecast', 'submarine.png', '30');\nINSERT INTO product (name, description, image, price) VALUES ('Glasses', 'Best Glasses', 'game.png', '100');\nFigure 13-2. Inserting products through phpMyAdmin.\nLet’s check that the products were successfully inserted. In phpMyAdmin, click the online_store  database, and\nclick the product table. Hopefully, you will see the four products inserted (see Fig. 13-3).\n",
      page_no: 43,
    },
    {
      id: 60,
      bookId: 33,
      content: "Figure 13-3. Products displayed in phpMyAdmin.\n",
      page_no: 44,
    },
    {
      id: 61,
      bookId: 33,
      content:
        "Chapter 14 – List Products with Database Data\nTo extract data from the MySQL database, we will create a ProductsService  (a Nest provider).\nIntroducing Nest Providers\nUntil now, we have introduced Nest Controllers and Modules. The last essential part of Nest applications is Nest\nProviders.\nA provider is a class or component that provides specific functionality to an application and can be injected as a\ndependency. Many basic Nest classes such as services, repositories, factories, and helpers may be treated as\nproviders. With providers, you delegate the instantiation of dependencies to the NestJS runtime system, instead of\ndoing it in your code imperatively. We will see how Nest instantiates and injects those dependencies later in this\nchapter.\nNest suggests that controllers should handle HTTP requests, and delegate more complex tasks to providers. For\nexample, storing a product into the database should be a provider’s task, not a controller’s task. More information\nabout Nest Providers can be found at: https://docs.nestjs.com/providers.\nTo define a provider, we need to create a class and attach the @Injectable() decorator. Let’s see a provider in\naction.\nCreating ProductsService\nIn src/models , create a new file called products.service.ts , and fill it with the following code.\nAdd Entire Code\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Product } from './product.entity';\n@Injectable()\nexport class ProductsService {\nconstructor(\n@InjectRepository(Product)\nprivate productsRepository: Repository<Product>,\n) {}\nfindAll(): Promise<Product[]> {\nreturn this.productsRepository.find();\n}\nfindOne(id: string): Promise<Product> {\nreturn this.productsRepository.findOne(id);\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\n@Injectable()\nexport class ProductsService {\nThe @Injectable()  decorator declares that ProductsService  can be injected and instantiated by Nest as a provider.\nAnalyze Code\nconstructor(\n@InjectRepository(Product)\nprivate productsRepository: Repository<Product>,\n) {}\nIn the constructor , the @InjectRepository()  decorator injects the products repository. The products repository\nmust be registered to be injected in our AppModule  later. We will explain how those Nest injections work in detail\nlater in this chapter.\nThe productsRepository  attribute is an instance of the Repository<Product>  class. TypeORM Repository  is a\nclass that works with our entity objects (in this case our Product  entity). The TypeORM Repository  class\nprovides a set of useful methods (such as find, create, remove, insert, and update) to manage a specific entity.\nAnalyze Code\nfindAll(): Promise<Product[]> {\n",
      page_no: 45,
    },
    {
      id: 62,
      bookId: 33,
      content:
        "return this.productsRepository.find();\n}\nThe  findAll  method returns a Promise consisting of an array of products. findAll  uses the productsRepository\nattribute, which invokes the  find  method (inherited from the TypeORM Repository  class) and returns all products\nfrom the database.\nAnalyze Code\nfindOne(id: string): Promise<Product> {\nreturn this.productsRepository.findOne(id);\n}\nThe  findOne  method receives an id and returns a Promise consisting of one product. This method uses the\nproductsRepository  attribute, invokes its  findOne  method (inherited from the TypeORM Repository  class), and\nreturns the specific product from the database based on id .\nNote: more information about the available TypeORM \nRepository  methods can be found here: \nhttps://typeorm.delightful.studio/classes/_repository_repository_.repository.html.\nModifying AppModule\nIn src/app.module.ts , make the following changes in bold.\nModify Bold Code\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { ProductsController } from './products.controller';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { ProductsService } from './models/products.service';\nimport { Product } from './models/product.entity';\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\nTypeOrmModule.forFeature([Product]),\n],\ncontrollers: [AppController, ProductsController],\nproviders: [ProductsService],\n})\nexport class AppModule {}\nWe import ProductsService and the Product  entity. We register ProductsService  in the module providers\nproperty. This means, that ProductsService will be available to be injected and used across AppModule  (for\nexample, \ninside \nAppController \nand \nProductsController ). \nWe \nalso \nregister \nthe\nTypeOrmModule.forFeature([Product])  in the module  imports  property. The forFeature()  method is used to\ndefine which TypeORM repositories are registered in the current scope. With that in place, Nest injects the products\nrepository into the ProductsService  constructor using the @InjectRepository()  decorator.\nModifying ProductsController\nIn src/products.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Param, Res } from '@nestjs/common';\nimport { ProductsService } from './models/products.service';\n@Controller('/products')\nexport class ProductsController {\nconstructor(private readonly productsService: ProductsService) {}\nstatic products = [\n{\nid: '1',\nname: 'TV',\ndescription: 'Best tv',\nimage: 'game.png',\nprice: '1000',\n},\n{\nid: '2',\nname: 'iPhone',\ndescription: 'Best iPhone',\nimage: 'safe.png',\nprice: '999',\n},\n",
      page_no: 46,
    },
    {
      id: 63,
      bookId: 33,
      content:
        "{\nid: '3',\nname: 'Chromecast',\ndescription: 'Best Chromecast',\nimage: 'submarine.png',\nprice: '30',\n},\n{\nid: '4',\nname: 'Glasses',\ndescription: 'Best Glasses',\nimage: 'game.png',\nprice: '100',\n},\n];\n@Get('/')\n@Render('products/index')\nasync index() {\nconst viewData = [];\nviewData['title'] = 'Products - Online Store';\nviewData['subtitle'] = 'List of products';\nviewData['products'] = ProductsController.products;\nviewData['products'] = await this.productsService.findAll();\nreturn {\nviewData: viewData,\n};\n}\n@Get('/:id')\n@Render('products/show')\nasync show(@Param() params, @Res() response) {\nconst product = ProductsController.products[params.id - 1];\nconst product = await this.productsService.findOne(params.id);\nif (product === undefined) {\nreturn response.redirect('/products');\n}\nconst viewData = [];\nviewData['title'] = product.name + ' - Online Store';\nviewData['subtitle'] = product.name + ' - Product Information';\nviewData['product'] = product;\nreturn {\nviewData: viewData,\n};\nreturn response.render('products/show', { viewData: viewData });\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\nimport { ProductsService } from './models/products.service';\n@Controller('/products')\nexport class ProductsController {\nconstructor(private readonly productsService: ProductsService) {}\nWe import the ProductsService  (remember this is a provider marked with the @Injectable()  decorator). Then, we\ndefine a constructor for our ProductsController  class. In the constructor, Nest will resolve the productsService\nprivate attribute by creating and returning an instance of ProductsService  (this is called “constructor injection”).\nNest will inject this instance since we registered the ProductsService  provider in the AppModule . Remember that\nthe AppModule  registered the AppController  and ProductsController  as controllers. So, all the providers\ndefined in the AppModule  will be available to be injected in the AppController  and ProductsController  when\nthey are needed. That is how Nest dependency injection works. It can be challenging to understand, so you can\ncheck out a more detailed explanation here: https://docs.nestjs.com/fundamentals/custom-providers.\nWe will use the ProductsService  to connect to the product  table.\nNote: Providers and dependency injection are fundamental concepts in Nest. You will find many examples and\ntutorials based on those concepts. There is also a great article that the Nest official documentation recommends\nreading: https://angular.io/guide/dependency-injection.\nAnalyze Code\nstatic products = [\n{\nid: '1',\nname: 'TV',\n",
      page_no: 47,
    },
    {
      id: 64,
      bookId: 33,
      content:
        "description: 'Best tv',\nimage: 'game.png',\nprice: '1000',\n},\n…\nWe remove the products dummy attribute since we don’t need it anymore. We will instead retrieve the products\ndata from the database.\nAnalyze Code\n@Get('/')\n@Render('products/index')\nasync index() {\nconst viewData = [];\nviewData['title'] = 'Products - Online Store';\nviewData['subtitle'] = 'List of products';\nviewData['products'] = ProductsController.products;\nviewData['products'] = await this.productsService.findAll();\nreturn {\nviewData: viewData,\n};\n}\nNote that we are not using the \nproducts  static attribute anymore. Instead, we invoke the\nthis.productsService.findAll()  method which returns a Promise with all the products collected from the database.\nSince that method returns a Promise, we use the await  keyword (which makes the application wait until that\npromise completes and returns its result). Once the products are returned from the database, the code continues its\nexecution, passes the  viewData  to the view, and renders the products/index  view. Finally, since we use the await\nkeyword, we must define the index method as async . More information about async/await can be found here:\nhttps://javascript.info/async-await.\nAnalyze Code\n@Get('/:id')\n@Render('products/show')\nasync show(@Param() params, @Res() response) {\nconst product = ProductsController.products[params.id - 1];\nconst product = await this.productsService.findOne(params.id);\nif (product === undefined) {\nreturn response.redirect('/products');\n}\nconst viewData = [];\nviewData['title'] = product.name + ' - Online Store';\nviewData['subtitle'] = product.name + ' - Product Information';\nviewData['product'] = product;\nreturn {\nviewData: viewData,\n};\nreturn response.render('products/show', { viewData: viewData });\n}\nWe remove the @Render  decorator because we will use redirections inside the show  method (and there is a\nconflict when using the @Render  decorator and redirection at the same time). We import and use the @Res\ndecorator in the response  method argument. This decorator allows us to access the express response object. Then,\nwe use the productsService.findOne method to retrieve the specific product from the database. If the product is not\nfound, we use the  response  object to redirect the user to the (“/products”) route. Otherwise, we set the viewData\nand use the response  object to render the original view with its data ( products/show ).\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNavigate to the (“/products”) route, and you will see the products retrieved from our MySQL database. Try to visit\na specific product with an id  that does not exists (i.e., “/products/21”), the application will be redirected to the\n(“/products”) route.\n",
      page_no: 48,
    },
    {
      id: 65,
      bookId: 33,
      content:
        "Chapter 15 – Refactoring List Products\nMany things can be improved in the previous code. For example, we will refactor our Product  entity,\nProductsController , and product  views . These changes will make our code more maintainable, understandable,\nand clean. Again, many of these changes apply not only to a Nest project but are also general tips that can be\nreplicated in most MVC frameworks.\nA project without getters and setters\nLet’s analyze our current code. It is an excerpt of our products.controller.ts  file.\nAnalyze Code\n@Get('/:id')\n@Render('products/show')\nasync show(@Param() params) {\n…\nconst viewData = [];\nviewData['title'] = product.name + ' - Online Store';\nviewData['subtitle'] = product.name + ' - Product Information';\nviewData['product'] = product;\nreturn {\nviewData: viewData,\n};\n}\nWe are accessing the product entity attributes directly ( product.name ). Now, let’s analyze the\nviews/products/show.hbs  view.\nAnalyze Code\n{{#with viewData.product}}\n…\n<h5 class=\"card-title\">\n{{name}} (${{price}})\n</h5>\n<p class=\"card-text\">{{description}}</p>\n<p class=\"card-text\"><small class=\"text-muted\">Add to Cart</small></p>\n…\n{{/with}}\nAgain, we are accessing the product’s name directly ( name ).\nWhat is the problem with accessing the entity data this way? Imagine that your boss tells you, “We need to display\nall products’ names in uppercase throughout the entire application”. That’s a big issue as we extract products’\nnames over several different views and controllers. This simple requirement will require us modifying several views\nand controllers. For now, let’s see what have to do to achieve that requirement.\nWe should modify the products.controller.ts  controller this way (do not implement this change, it is used just to\nexemplify this scenario):\nAnalyze Code\n@Get('/:id')\n@Render('products/show')\nasync show(@Param() params) {\n…\nconst viewData = [];\nviewData['title'] = product.name . toUpperCase() + ' - Online Store';\nviewData['subtitle'] = product.name.toUpperCase() + ' - Product Information';\nviewData['product'] = product;\nreturn {\nviewData: viewData,\n};\n}\nAnd the views/products/show.hbs  view this way (do not implement this change, it is used just to exemplify this\nscenario):\nAnalyze Code\n{{#with viewData.product}}\n…\n<h5 class=\"card-title\">\n{{loud name}} (${{price}})\n</h5>\n<p class=\"card-text\">{{description}}</p>\n<p class=\"card-text\"><small class=\"text-muted\">Add to Cart</small></p>\n…\n",
      page_no: 49,
    },
    {
      id: 66,
      bookId: 33,
      content:
        "{{/with}}\nFinally, we should create and register a hbs helper (called loud ). Let’s look at that helper.\nAnalyze Code\nHandlebars.registerHelper('loud', function (aString) {\nreturn aString.toUpperCase()\n})\nThere are two significant issues with this strategy. (i) We have many duplicate codes throughout the application (the\ntoUpperCase  function is used over several places). (ii) We must check all controllers, all views, and maybe dozens\nor hundreds of files to check where we need to apply the toUpperCase  function or the  loud  hbs custom helper.\nThis is not maintainable. So, let’s refactor our code to implement a better strategy.\nProject with getters and setters\nRefactoring the Product Entity\nFirst, let’s refactor our Product entity. In src/models/product.entity.ts , make the following changes in bold.\nModify Bold Code\n...\n@Entity()\nexport class Product {\n...\n@Column()\nprice: number;\ngetId(): number {\nreturn this.id;\n}\nsetId(id: number) {\nthis.id = id;\n}\ngetName(): string {\nreturn this.name;\n}\nsetName(name: string) {\nthis.name = name;\n}\ngetDescription(): string {\nreturn this.description;\n}\nsetDescription(description: string) {\nthis.description = description;\n}\ngetImage(): string {\nreturn this.image;\n}\nsetImage(image: string) {\nthis.image = image;\n}\ngetPrice(): number {\nreturn this.price;\n}\nsetPrice(price: number) {\nthis.price = price;\n}\n}\nFor each Product  attribute, we define its corresponding getter and setter. We will use getters and setters to access\nand modify our entity/model attributes. It has a lot of advantages which we will talk about later.\nRefactoring the ProductsController\n",
      page_no: 50,
    },
    {
      id: 67,
      bookId: 33,
      content:
        'In src/products.controller.ts , make the following changes in bold.\nModify Bold Code\n...\n@Get(\'/:id\')\nasync show(@Param() params, @Res() response) {\nconst product = await this.productsService.findOne(params.id);\nif (product === undefined) {\nreturn response.redirect(\'/products\');\n}\nconst viewData = [];\nviewData[\'title\'] = product.getName() + \' - Online Store\';\nviewData[\'subtitle\'] = product.getName() + \' - Product Information\';\nviewData[\'product\'] = product;\nreturn response.render(\'products/show\', { viewData: viewData });\n}\n}\nNow, we access the product  attributes through the corresponding getters.\nRefactoring the products/index view\nIn views/products/index.hbs , make the following changes in bold.\nModify Bold Code\n...\n{{#each viewData.products}}\n<div class="col-md-4 col-lg-3 mb-2">\n<div class="card">\n<img src="/img/{{getImage}}" class="card-img-top img-card">\n<div class="card-body text-center">\n<a href="/products/{{getId}}" class="btn bg-primary text-white">{{getName}}</a>\n</div>\n</div>\n</div>\n{{/each}}\n...\nLike the previous controller, we access the product attributes through the corresponding getters. Notice that hbs\ndon’t allow parentheses ‘()’ so getters should be called without them.\nRefactoring the products/show view\nIn views/products/show.hbs , make the following changes in bold.\nModify Bold Code\n{{#> app}}\n{{#*inline "content"}}\n{{#with viewData.product}}\n<div class="card mb-3">\n<div class="row g-0">\n<div class="col-md-4">\n<img src="/img/{{getImage}}" class="img-fluid rounded-start">\n</div>\n<div class="col-md-8">\n<div class="card-body">\n<h5 class="card-title">\n{{getName}} (${{getPrice}})\n</h5>\n<p class="card-text">{{getDescription}}</p>\n<p class="card-text"><small class="text-muted">Add to Cart</small></p>\n</div>\n</div>\n</div>\n</div>\n{{/with}}\n{{/inline}}\n{{/app}}\nWe access the product  attributes through getters.\nAnalyzing getters and setters\nFor now, the application looks the same. We only modified the way we access entity attributes. So, what is the\nadvantage? Let’s revisit the boss requirement where we need to display all products’ names in uppercase over the\nentire application.\nIn this case, we only need to modify the  Product  entity file. Specifically, the getName  method. Let’s see the\n',
      page_no: 51,
    },
    {
      id: 68,
      bookId: 33,
      content:
        "modification (you can apply the following change or leave it as it is).\nAnalyze Code\n...\ngetName(): string {\nreturn this.name.toUpperCase();\n}\n...\nIf you run the application, you will see that all products’ names appear in uppercase. We only required one single\nchange in one specific location. That is the power of the use of getters or setters. The definition and use of getters\nand setters guarantee a unique access point to the entity/model attributes. That is part of what some people call\nencapsulation, one of the three pillars of object-oriented programming.\nTIP: Always try to access your entity/model attributes through getters and setters. It will make\nit easier to add functionalities in the future. You can even include a new rule saying that\nentities/models’ attributes must be accessed through their corresponding getters and setters (in\nyour architectural rules document).\nFor the rest of the application, we will use the getters and setters’ strategy. We hope you understand their\nimportance now.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nThe application should be properly working. If you applied the modification in the getName  method, you would\nsee all products’ names in uppercase (see Fig. 15-1).\nFigure 15-1. Accessing a product with the modified getName  method.\n",
      page_no: 52,
    },
    {
      id: 69,
      bookId: 33,
      content:
        'Chapter 16 – Admin Panel\nMany web applications have an admin section that administrators or moderators can access to manage the\napplication data such as registering products, managing sales, generating reports, and managing users. Commonly,\nthis section is called an administration panel. Due to its nature, this section is secured by a login or authentication\nsystem. For now, we will create a public administration panel, which any visitor can access. We will later\nimplement a login system to secure and verify that only allowed users (admins) can access this section.\nTo create the admin panel, we need to include a layout, a controller, a view, some new files, and a new module. So,\nlet’s begin.\nAdmin Layout\nCommonly, administration panels look different from the main pages. They are quite minimal, and many of them\ndisplay information like a spreadsheet. Let’s start our admin panel construction by defining a new layout. This\nlayout will be used across the admin panel pages.\nIn views/layouts , create a new file called admin.hbs , and fill it with the following code.\nAdd Entire Code\n<!doctype html>\n<html lang="en">\n<head>\n<meta charset="utf-8" />\n<meta name="viewport" content="width=device-width, initial-scale=1" />\n<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet"\ncrossorigin="anonymous" />\n<link href="/css/admin.css" rel="stylesheet" />\n<title>{{#if viewData.title}}{{ viewData.title }}{{else}}Admin - Online Store{{/if}}</title>\n</head>\n<body>\n<div class="row g-0">\n<!-- sidebar -->\n<div class="p-3 col fixed text-white bg-dark">\n<a href="/admin" class="text-white text-decoration-none">\n<span class="fs-4">Admin Panel</span>\n</a>\n<hr />\n<ul class="nav flex-column">\n<li><a href="/admin" class="nav-link text-white">- Admin - Home</a></li>\n<li><a href="#" class="nav-link text-white">- Admin - Products</a></li>\n<li>\n<a href="/" class="mt-2 btn bg-primary text-white">Go back to the home page</a>\n</li>\n</ul>\n</div>\n<!-- sidebar -->\n<div class="col content-grey">\n<nav class="p-3 shadow text-end">\n<span class="profile-font">Admin</span>\n<img class="img-profile rounded-circle" src="/img/undraw_profile.svg">\n</nav>\n<div class="g-0 m-5">\n{{> content}}\n</div>\n</div>\n</div>\n<!-- footer -->\n<div class="copyright py-4 text-center text-white">\n<div class="container">\n<small>\nCopyright - <a class="text-reset fw-bold text-decoration-none" target="_blank"\nhref="https://twitter.com/danielgarax">\nDaniel Correa\n</a> - <a class="text-reset fw-bold text-decoration-none" target="_blank"\nhref="https://twitter.com/greglim81">\nGreg Lim\n</a>\n</small>\n</div>\n</div>\n',
      page_no: 53,
    },
    {
      id: 70,
      bookId: 33,
      content:
        '<!-- footer -->\n  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous">\n  </script>\n</body>\n</html>\nNote: \nRemember \nyou \ncan \nfind \nthe \napplication \ncode \nat \nthe \nGitHub \nrepository \nin\nhttps://github.com/PracticalBooks/Practical-Nest.\nWe have a new layout. This layout presents a different structure and contains a sidebar with three links.\n• “- Admin - Home” links to the admin panel home page.\n• “- Admin - Products” links to the admin panel product management page (this page will be implemented in\nthe next chapter).\n• “Go back to the home page” links back to the online store home page.\nThe admin.hbs  layout imports an admin.css  file and a new image. Let’s add these elements to our project.\nCreating the admin.css file\nIn public/css  create a new file called admin.css  and fill it with the following code.\nAdd Entire Code\n.copyright {\nbackground-color: #1a252f;\n}\n.fixed {\n-ms-flex: 0 0 250px;\nflex: 0 0 250px;\n}\n.content-grey {\nbackground-color: #f8f9fc;\n}\nhr {\nmargin-top: 0.8em;\nmargin-bottom: 0.8em;\n}\n.img-profile {\nheight: 2rem;\nwidth: 2rem;\n}\n.profile-font {\ncolor: #858796 !important;\nfont-size: 80%;\nfont-weight: 400;\n}\n.card-header {\nbackground-color: #f8f9fc;\nborder-bottom: 1px solid #e3e6f0;\n}\nWe have some custom CSS classes. Most of them are used in the  admin  layout.\nAdding the undraw profile image\nDownload \nundraw_profile.svg  \nfile \nfrom \nthis \nlink \nhttps://github.com/PracticalBooks/Practical-\nNest/blob/main/Chapter16/online-store/public/img/undraw_profile.svg and store it inside the public/img  folder. Or\nstore your own admin profile image.\nAdminController\nIn src/ , create a subfolder called admin . Then, in src/admin  create a new file admin.controller.ts  and fill it with\nthe following code.\nAdd Entire Code\nimport { Controller, Get, Render } from \'@nestjs/common\';\n',
      page_no: 54,
    },
    {
      id: 71,
      bookId: 33,
      content:
        "@Controller('/admin')\nexport class AdminController {\n@Get('/')\n@Render('admin/index')\nindex() {\nconst viewData = [];\nviewData['title'] = 'Admin Page - Admin - Online Store';\nreturn {\nviewData: viewData,\n};\n}\n}\nWe have a simple index  method, linked to the (“/admin/”) route that displays the views/admin/index.hbs  view.\nAdmin index view\nNow, let’s create the admin index  view. In views/ , create a subfolder called admin . Then, in views/admin  create\na new file called index.hbs  and fill it with the following code.\nAdd Entire Code\n{{#> admin}}\n{{#*inline \"content\"}}\n<div class=\"card\">\n<div class=\"card-header\">\nAdmin Panel - Home Page\n</div>\n<div class=\"card-body\">\nWelcome to the Admin Panel, use the sidebar to navigate between the different options.\n</div>\n</div>\n{{/inline}}\n{{/admin}}\nWe have a simple view that displays a “welcome to the admin panel” message. Note that this view uses the new\nadmin  layout (not the app  layout).\nAdmin Module\nIn src/admin , create a new file called admin.module.ts  and fill it with the following code.\nAdd Entire Code\nimport { Module } from '@nestjs/common';\nimport { AdminController } from './admin.controller';\n@Module({\ncontrollers: [AdminController],\n})\nexport class AdminModule {}\nWe created the AdminModule  and register AdminController .\nRegistering AdminModule in AppModule\nLet’s register the AdminModule  in the application root module ( AppModule ). In src/app.module.ts , make the\nfollowing changes in bold.\nModify Bold Code\n…\nimport { ProductsService } from './models/products.service';\nimport { Product } from './models/product.entity';\nimport { AdminModule } from './admin/admin.module';\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\nTypeOrmModule.forFeature([Product]),\nAdminModule,\n],\ncontrollers: [AppController, ProductsController],\nproviders: [ProductsService],\n})\nexport class AppModule {}\nWe import AdminModule  and register it in the module  imports  property. This makes the route defined in\nAdminController  accessible.\n",
      page_no: 55,
    },
    {
      id: 72,
      bookId: 33,
      content:
        "Running the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/admin”) route, and you will see the new Admin Panel (see Fig. 16-1).\nFigure 16-1. Online Store – Admin Panel.\n",
      page_no: 56,
    },
    {
      id: 73,
      bookId: 33,
      content:
        'Chapter 17 – List Products in Admin Panel\nLet’s create the admin product management section. For now, we will create an index page that lists all products.\nAdminProductsController\nIn src/admin , create a new file called admin.products.controller.ts  and fill it with the following code.\nAdd Entire Code\nimport { Controller, Get, Render } from \'@nestjs/common\';\nimport { ProductsService } from \'../models/products.service\';\n@Controller(\'/admin/products\')\nexport class AdminProductsController {\nconstructor(private readonly productsService: ProductsService) {}\n@Get(\'/\')\n@Render(\'admin/products/index\')\nasync index() {\nconst viewData = [];\nviewData[\'title\'] = \'Admin Page - Admin - Online Store\';\nviewData[\'products\'] = await this.productsService.findAll();\nreturn {\nviewData: viewData,\n};\n}\n}\nWe create the AdminProductsController  class. We imported the ProductsService  which will be injected in the\nproductsService  attribute. Then, we define the index  method that collects the products data (though the\nproductsService.findAll  method) and renders the admin.products.index  view.\nAdmin products index view\nIn views/admin , create a subfolder called products . In views/admin/products  create a new file index.hbs  and fill\nit with the following code.\nAdd Entire Code\n{{#> admin}}\n{{#*inline "content"}}\n<div class="card">\n<div class="card-header">\nManage Products\n</div>\n<div class="card-body">\n<table class="table table-bordered table-striped">\n<thead>\n<tr>\n<th scope="col">ID</th>\n<th scope="col">Name</th>\n<th scope="col">Edit</th>\n<th scope="col">Delete</th>\n</tr>\n</thead>\n<tbody>\n{{#each viewData.products}}\n<tr>\n<td>{{getId}}</td>\n<td>{{getName}}</td>\n<td>Edit</td>\n<td>Delete</td>\n</tr>\n{{/each}}\n</tbody>\n</table>\n</div>\n</div>\n{{/inline}}\n{{/admin}}\nWe have a table which displays the products’ ids and names. This table was designed based on Bootstrap Tables\n(https://getbootstrap.com/docs/5.1/content/tables/). Later, we will include a link to edit and delete specific products.\nRegistering AdminProductsController\n',
      page_no: 57,
    },
    {
      id: 74,
      bookId: 33,
      content:
        'In src/admin/admin.module.ts , make the following changes in bold.\nModify Bold Code\nimport { Module } from \'@nestjs/common\';\nimport { AdminController } from \'./admin.controller\';\nimport { AdminProductsController } from \'./admin.products.controller\';\n@Module({\ncontrollers: [AdminController, AdminProductsController],\n})\nexport class AdminModule {}\nRunning the app\nLet’s try to run the app. In the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nYou will get an error saying that “Nest can\'t resolve dependencies of the AdminProductsController”. Basically,\nthere is a problem trying to inject the ProductsService  in the AdminProductsController constructor. It is because\nwe have not registered the ProductsService  as a provider in AdminModule . Because we registered it only in\nAppModule , ProductsService is available to be injected only under the AppModule  scope, not the AdminModule\nscope.\nHere we have two options (i) import the ProductsService  and register it as a provider in the AdminModule  file.\nBut we will also need to import and register the TypeOrmModule  (because remember that the ProductsService\ninjects a TypeORM repository). Or (ii) make the AppModule  a global module (to avoid importing or registering\nthe same providers over multiple modules).\nLet’s implement the second option.\nGlobal AppModule\nIn src/app.module.ts , make the following changes in bold.\nModify Bold Code\nimport { Module, Global } from \'@nestjs/common\';\n…\n@Global()\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\nTypeOrmModule.forFeature([Product]),\nAdminModule,\n],\ncontrollers: [AppController, ProductsController],\nproviders: [ProductsService],\nexports: [ProductsService],\n})\nexport class AppModule {}\nWe imported the Global  decorator and marked  AppModule  with it. The @Global  decorator makes the\nAppModule  global-scoped, making the AppModule  providers available everywhere (not only attached to the\nAppModule  scope). We use the exports  property to specify which providers will be available in other modules. In\nthis case, the ProductsService  provider will be available in all modules since we used the @Global  decorator.\nNow, Nest can inject the ProductsService  in the AdminProductsController constructor (without requiring us to\nimport or register it in the AdminModule ).\nUpdating links in Admin layout\nNow that we have the proper admin products route, let’s include it in the \nadmin  layout. In\nviews/layouts/admin.hbs , make the following changes in bold.\nModify Bold Code\n...\n<!-- sidebar -->\n...\n<ul class="nav flex-column">\n<li><a href="/admin" class="nav-link text-white">- Admin - Home</a></li>\n<li><a href="/admin/products" class="nav-link text-white">- Admin - Products</a></li>\n<li>\n',
      page_no: 58,
    },
    {
      id: 75,
      bookId: 33,
      content:
        '<a href="/" class="mt-2 btn bg-primary text-white">Go back to the home page</a>\n</li>\n</ul>\n</div>\n<!-- sidebar -->\n...\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/admin/products”) route, and you will see the new Admin Product page (see Fig. 17-1). Remember\nthat you will need to have MySQL running; otherwise, you will get a database connection error.\nFigure 17-1. Online Store – Admin Panel – Products.\n',
      page_no: 59,
    },
    {
      id: 76,
      bookId: 33,
      content:
        'Chapter 18 – Create Products\nNow, we will focus on the admin panel system to create products.\nModifying admin/products/index.hbs view\nIn views/admin/products/index.hbs , make the following changes in bold.\nModify Bold Code\n{{#> admin}}\n{{#*inline "content"}}\n<div class="card mb-4">\n<div class="card-header">\nCreate Products\n</div>\n<div class="card-body">\n<form method="POST" action="/admin/products/store">\n<div class="row">\n<div class="col">\n<div class="mb-3 row">\n<label class="col-lg-2 col-md-6 col-sm-12 col-form-label">Name:</label>\n<div class="col-lg-10 col-md-6 col-sm-12">\n<input name="name" type="text" class="form-control" required>\n</div>\n</div>\n</div>\n<div class="col">\n<div class="mb-3 row">\n<label class="col-lg-2 col-md-6 col-sm-12 col-form-label">Price:</label>\n<div class="col-lg-10 col-md-6 col-sm-12">\n<input name="price" type="number" class="form-control" required>\n</div>\n</div>\n</div>\n</div>\n<div class="mb-3">\n<label class="form-label">Description</label>\n<textarea class="form-control" name="description" rows="3" required></textarea>\n</div>\n<button type="submit" class="btn btn-primary">Submit</button>\n</form>\n</div>\n</div>\n<div class="card">\n<div class="card-header">\nManage Products\n...\nLet’s analyze the code by parts.\nAnalyze Code\n<form method="POST" action="/admin/products/store">\n…\n<button type="submit" class="btn btn-primary">Submit</button>\n</form>\nWe have an HTML \nform . This \nform  specifies a POST method and links the form with the\n(“/admin/products/store”) route. This route will be attached to a controller method later. The POST method is used\nto send data to the application server. Finally, we have the submit  button to submit the form.\nAnalyze Code\n<div class="mb-3 row">\n<label class="col-lg-2 col-md-6 col-sm-12 col-form-label">Name:</label>\n<div class="col-lg-10 col-md-6 col-sm-12">\n<input name="name" type="text" class="form-control" required>\n</div>\n</div>\nThe rest of the code shows form inputs, buttons, and a textarea. This form and elements were designed based on\nBootstrap Forms (https://getbootstrap.com/docs/5.1/forms/overview/). They show an input to enter the product\nname.\nNote: we are not yet collecting the product image. We will do so in the next chapter.\nWARNING: Our forms are not protected against Cross-site request forgery (CSRF) attacks. To\nprotect against CSRF, we should use a library to generate CSRF tokens and use those tokens in our\n',
      page_no: 60,
    },
    {
      id: 77,
      bookId: 33,
      content:
        "forms. Then, the application can validate that the form request comes from our trusted site. Nest\nsuggests using the csurf  library. However, the implementation is out of the scope of this book.\nMore information can be found here: https://docs.nestjs.com/security/csrf.\nModifying AdminProductsController\nNext, we create the store  method in AdminProductsController . In src/admin/admin.products.controller.ts , make\nthe following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Post, Body, Redirect } from '@nestjs/common';\nimport { ProductsService } from '../models/products.service';\nimport { Product } from '../models/product.entity';\n@Controller('/admin/products')\nexport class AdminProductsController {\n...\n@Post('/store')\n@Redirect('/admin/products')\nasync store(@Body() body) {\nconst newProduct = new Product();\nnewProduct.setName(body.name);\nnewProduct.setDescription(body.description);\nnewProduct.setPrice(body.price);\nnewProduct.setImage('game.png');\nawait this.productsService.createOrUpdate(newProduct);\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\n@Post('/store')\n@Redirect('/admin/products')\nasync store(@Body() body) {\nWe use the @Post  decorator in our store  method to receive form data. This controller method won’t render a\nview. Instead, it redirects to the (“/admin/products”) route using the @Redirect  decorator. Finally, the store\nmethod receives the data from the admin/products/index.hbs  form. To extract this information, we use the\n@Body  decorator. The @Body  decorator maps the inputs received from the form into the body  variable.\nAnalyze Code\nconst newProduct = new Product();\nnewProduct.setName(body.name);\nnewProduct.setDescription(body.description);\nnewProduct.setPrice(body.price);\nnewProduct.setImage('game.png');\nawait this.productsService.createOrUpdate(newProduct);\nWe create a new Product  instance. Then, we set the product name , description , and price  based on the values\ncollected from the form’s body  variable. We currently set a default product image ( game.png ). Finally, we invoke\nthe productsService.createOrUpdate method and pass in newProduct  to create the new product in the database (or\nupdate it if it exists). We will implement the createOrUpdate  method in the next section.\nModifying ProductsService\nIn src/models/products.service.ts , make the following changes in bold.\nModify Bold Code\n...\n@Injectable()\nexport class ProductsService {\n...\nfindOne(id: string): Promise<Product> {\nreturn this.productsRepository.findOne(id);\n}\ncreateOrUpdate(product: Product): Promise<Product> {\nreturn this.productsRepository.save(product);\n}\n}\nThe  createOrUpdate  method receives a Product  instance  and returns a Promise consisting of a product. This\n",
      page_no: 61,
    },
    {
      id: 78,
      bookId: 33,
      content:
        "method uses the productsRepository  attribute which invokes its  save  method (inherited from the TypeORM\nRepository  class). This saves the product in the database (creates a new one if it doesn’t exist or updates an existing\none) and returns a new object based on the saved product.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/admin/products”) route, and you will see the new form. When you complete and submit the form\n(see Fig. 18-1), you will see the new product listed in the admin panel (see Fig. 18-2).\nFigure 18-1. Online Store – Refined Admin Panel – Products.\nFigure 18-2. New product listed.\nWe have a couple of problems with the current implementation. We are not collecting the product images from the\nform, and we are not validating the product data. For example, we can create products with negative prices (i.e.,\n-180). We will implement the product image in the next chapter. However, we will need to wait some chapters to\nintroduce the concepts of sessions and apply the proper validations.\n",
      page_no: 62,
    },
    {
      id: 79,
      bookId: 33,
      content:
        'Chapter 19 – Create Products with Images\nIn the previous chapter, we created all our products with a default game.png  image. Let’s fix this and enable\nuploading images.\nInstalling Image Upload Support Library\nTo handle file uploading, Nest provides a built-in module based on the multer middleware package for Express.\nMulter handles data posted in the multipart/form-data format primarily used for uploading files via an HTTP POST\nrequest. For better type safety, Nest suggests installing a Multer typings package. Let’s install it. In the Terminal, go\nto the project directory, and execute the following:\nExecute in Terminal\nnpm install -D @types/multer\nModifying admin/products/index view\nIn views/admin/products/index.hbs , make the following changes in bold.\nModify Bold Code\n@extends(\'layouts.admin\')\n@section(\'title\', $viewData["title"])\n@section(\'content\')\n...\n<form method="POST" action="/admin/products/store" enctype="multipart/form-data">\n<div class="row">\n...\n</div>\n<div class="row">\n<div class="col">\n<div class="mb-3 row">\n<label class="col-lg-2 col-md-6 col-sm-12 col-form-label">Image:</label>\n<div class="col-lg-10 col-md-6 col-sm-12">\n<input class="form-control" type="file" name="image">\n</div>\n</div>\n</div>\n<div class="col">\n&nbsp;\n</div>\n</div>\n<div class="mb-3">\n<label class="form-label">Description</label>\n...\nWe include an enctype="multipart/form-data"  attribute in our form. This attribute is used in form elements that\nhave a file upload. Then, we add a file upload input (called image ) where the admin user will select the product\nimage.\nModifying AdminProductsController\nIn src/admin/admin.products.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Post, Body, Redirect,\nUseInterceptors, UploadedFile } from \'@nestjs/common\';\nimport { FileInterceptor } from \'@nestjs/platform-express\';\nimport { ProductsService } from \'../models/products.service\';\nimport { Product } from \'../models/product.entity\';\n@Controller(\'/admin/products\')\nexport class AdminProductsController {\n…\n@Post(\'/store\')\n@UseInterceptors(FileInterceptor(\'image\', { dest: \'./public/uploads\' }))\n@Redirect(\'/admin/products\')\nasync store(@Body() body, @UploadedFile() file: Express.Multer.File) {\nconst newProduct = new Product();\nnewProduct.setName(body.name);\nnewProduct.setDescription(body.description);\nnewProduct.setPrice(body.price);\nnewProduct.setImage(file.filename);\nawait this.productsService.createOrUpdate(newProduct);\n}\n',
      page_no: 63,
    },
    {
      id: 80,
      bookId: 33,
      content:
        '}\nWe import the UseInterceptors , UploadedFile , and FileInterceptor  decorators. To upload our image file, we\nneed to use the @UseInterceptors  decorator tied to a specific route (in this case “/admin/products/store”). Then,\nwe place the FileInterceptor inside the @UseInterceptors  decorator. This FileInterceptor  will be tied to the\n(“/admin/products/store”) route, extract the file from the request, upload the file to the public/uploads  folder, and\nplace the uploaded file information in the file  variable using the @UploadedFile  decorator.\nThe FileInterceptor()  decorator takes two arguments:\n• fieldName:  name of the field from the HTML form that holds a file. In our case, remember we create an input\nfile with the image  name.\n• options: optional object of type MulterOptions. In our case, we pass the destination where we want to store the\nimage (the public/uploads  folder). More information about multer options can be found here:\nhttps://github.com/expressjs/multer#multeropts.\nFinally, we modify the newProduct.setImage  argument. We remove the previous game.png  default filename and\npass the filename of the file uploaded by the multer library.\nWARNING: The current code allows us to upload any kind of file type. This could lead to\nhackers injecting malicious code. We will refactor this code later to implement proper file type\nvalidations.\nModifying products/index and products/show views\nIn views/products/index.hbs , make the following changes in bold.\nModify Bold Code\n...\n{{#each viewData.products}}\n…\n<img src="/uploads/{{getImage}}" class="card-img-top img-card">\n…\n{{/each}}\n...\nIn views/products/show.hbs , make the following changes in bold.\nModify Bold Code\n...\n<div class="col-md-4">\n<img src="/uploads/{{getImage}}" class="img-fluid rounded-start">\n</div>\n...\nNow, we are accessing the product images through the uploads  folder path.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow, go to the (“/admin/products”) route, and you will see the new form (see Fig. 19-1). Complete the form, upload\nan image, and create a new product. \nFigure 19-1. Online Store – Create products form with image selection.\n',
      page_no: 64,
    },
    {
      id: 81,
      bookId: 33,
      content:
        "Now, go to the (“/products”) route. You will see the new product image loaded. However, the old product images\nare not loading (see Fig. 19-2). This is because we changed the path from where we are loading the images. Don’t\nworry. In the next chapter, we will implement a way to edit our products and upload proper images for the rest of\nour products.\nFigure 19-2. Online Store – List products with their uploaded images.\nQuick discussion: There is a tremendous advantage of using the multer library for uploading\nproduct images. Before, we manually downloaded and added the products’ images to the\npublic/img  folder. This is a manual task which does not scale well. It requires access to the\napplication code (but not all admins will have it). Now, we automate this process with the\nproduct registration form and the use of the multer library. Multer interacts with our server\nfilesystem and places the images in their proper folder location.\nNote: if you try to create a new product without selecting an image, you will get a Nest 500 error. We will\nimplement product form validation and a proper way to display the errors in upcoming chapters.\n",
      page_no: 65,
    },
    {
      id: 82,
      bookId: 33,
      content:
        'Chapter 20 – Edit and Delete Products\nLet’s start with deleting products since it is relatively simple. And then, we will implement the edit products\nfunctionality.\nDeleting products\nTo delete a product, we will need to modify a set of files.\nModifying ProductsService\nIn src/models/products.service.ts , make the following changes in bold.\nModify Bold Code\n...\n@Injectable()\nexport class ProductsService {\n...\nasync remove(id: string): Promise<void> {\nawait this.productsRepository.delete(id);\n}\n}\nThe  remove  method receives the id  of a product and returns a void  Promise. remove  uses the\nproductsRepository  attribute, invokes its  delete  method (inherited from the TypeORM Repository  class), and\ndeletes the corresponding product from the database.\nModifying AdminProductsController\nIn src/admin/admin.products.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Post, Body, Redirect,\nUseInterceptors, UploadedFile, Param } from \'@nestjs/common\';\nimport { FileInterceptor } from \'@nestjs/platform-express\';\n...\n@Controller(\'/admin/products\')\nexport class AdminProductsController {\n...\n@Post(\'/:id\')\n@Redirect(\'/admin/products\')\nremove(@Param(\'id\') id: string) {\nreturn this.productsService.remove(id);\n}\n}\nLike the store  method, the remove method won’t render a view. Instead, it redirects to the (“/admin/products”)\nroute using the @Redirect  decorator. The remove  method contains an id  argument. We use the @Param(\'id\')\nto decorate the id  argument, collect an id  value from the request route and assign it to the id  argument. Finally,\nwe invoke productsService.remove  with id  to delete the product.\nModifying view/layout/admin\nIn views/layout/admin.hbs , make the following changes in bold.\nModify Bold Code\n<!doctype html>\n<html lang="en">\n<head>\n<meta charset="utf-8" />\n<meta name="viewport" content="width=device-width, initial-scale=1" />\n<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet"\ncrossorigin="anonymous" />\n  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">\n...\nWe add a link to a CSS file (Bootstrap icons). This CSS file allows us to use specific icons and fonts inside our\nviews. For example, we will have icons to edit and delete our products. More information about Bootstrap icons can\nbe found at: https://icons.getbootstrap.com/.\n',
      page_no: 66,
    },
    {
      id: 83,
      bookId: 33,
      content:
        'Modifying admin/products/index view\nIn views/admin/products/index.hbs , make the following changes in bold.\nModify Bold Code\n...\n{{#each viewData.products}}\n<tr>\n<td>{{getId}}</td>\n<td>{{getName}}</td>\n<td>Edit\n<button class="btn btn-primary">\n<i class="bi-pencil"></i>\n</button>\n</td>\n          <td>Delete\n<form action="/admin/products/{{getId}}" method="POST">\n<button class="btn btn-danger">\n<i class="bi-trash"></i>\n</button>\n</form>\n</td>\n</tr>\n{{/each}}\n...\nWe removed the “Edit” and “Delete” text and replaced them with a couple of buttons. Inside those buttons, we use\nBootstrap icons (a pencil  icon to edit a product and a  trash  icon to delete a product). We completed the delete\nfunctionality by wrapping a form around the delete icon. This form will invoke the (“/admin/products/:id”) route\nand pass the current product id .\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/admin/products”) route, and you will see the new form (see Fig. 20-1). Now, try to create a\ndummy product and delete it.\nFigure 20-1. Online Store – Refined Admin Panel – Products.\nEditing products\nLike the previous delete functionality, we will need to modify a set of files.\nModifying AdminProductsController\nIn src/admin/admin.products.controller.ts , make the following changes in bold.\nModify Bold Code\n...\n@Controller(\'/admin/products\')\nexport class AdminProductsController {\n...\n@Get(\'/:id\')\n@Render(\'admin/products/edit\')\n',
      page_no: 67,
    },
    {
      id: 84,
      bookId: 33,
      content:
        "async edit(@Param('id') id: string) {\nconst viewData = [];\nviewData['title'] = 'Admin Page - Edit Product - Online Store';\nviewData['product'] = await this.productsService.findOne(id);\nreturn {\nviewData: viewData,\n};\n}\n@Post('/:id/update')\n@UseInterceptors(FileInterceptor('image', { dest: './public/uploads' }))\n@Redirect('/admin/products')\nasync update(\n@Body() body,\n@UploadedFile() file: Express.Multer.File,\n@Param('id') id: string\n) {\nconst product = await this.productsService.findOne(id);\nproduct.setName(body.name);\nproduct.setDescription(body.description);\nproduct.setPrice(body.price);\nif (file) {\nproduct.setImage(file.filename);\n}\nawait this.productsService.createOrUpdate(product);\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\n@Get('/:id')\n@Render('admin/products/edit')\nasync edit(@Param('id') id: string) {\nconst viewData = [];\nviewData['title'] = 'Admin Page - Edit Product - Online Store';\nviewData['product'] = await this.productsService.findOne(id);\nreturn {\nviewData: viewData,\n};\n}\nWe have an edit  method that searches for a product based on its id  (received from the route) and sends it to the\nadmin/products/edit  view. This is the product we are going to edit.\nAnalyze Code\n@Post('/:id/update')\n@UseInterceptors(FileInterceptor('image', { dest: './public/uploads' }))\n@Redirect('/admin/products')\nasync update(\n@Body() body,\n@UploadedFile() file: Express.Multer.File,\n@Param('id') id: string\n) {\nconst product = await this.productsService.findOne(id);\nproduct.setName(body.name);\nproduct.setDescription(body.description);\nproduct.setPrice(body.price);\nif (file) {\nproduct.setImage(file.filename);\n}\nawait this.productsService.createOrUpdate(product);\n}\nThen, we have the update  method. It is like the store method.\n1 We collect the  id  from the route parameter, which indicates the product to be updated.\n2 We search for a product based on that  id , and to that product we set the new name ,  price , and description .\nThat data is collected in a form that we will show later.\n3 We set the new product image  value if a new image  was uploaded.\n4 Finally, we invoke the productsService.createOrUpdate method with the updated product to update it in the\ndatabase.\nModifying admin/products/index view\nIn views/admin/products/index.hbs , make the following changes in bold.\n",
      page_no: 68,
    },
    {
      id: 85,
      bookId: 33,
      content:
        'Modify Bold Code\n...\n{{#each viewData.products}}\n<tr>\n<td>{{getId}}</td>\n<td>{{getName}}</td>\n<td>\n<a class="btn btn-primary" href="/admin/products/{{getId}}">\n<button class="btn btn-primary">\n<i class="bi-pencil"></i>\n</button>\n</a>\n</td>\n          …\n</tr>\n{{/each}}\n...\nNow, we link the pencil icon with the product edit route and pass in the current product id .\nCreating admin/products/edit view\nIn views/admin/products/ create a new file called edit.hbs and fill it with the following code.\nAdd Entire Code\n{{#> admin}}\n{{#*inline "content"}}\n<div class="card mb-4">\n<div class="card-header">\nEdit Product\n</div>\n<div class="card-body">\n{{#with viewData.product}}\n<form method="POST" action="/admin/products/{{getId}}/update" enctype="multipart/form-data">\n<div class="row">\n<div class="col">\n<div class="mb-3 row">\n<label class="col-lg-2 col-md-6 col-sm-12 col-form-label">Name:</label>\n<div class="col-lg-10 col-md-6 col-sm-12">\n<input name="name" value="{{getName}}" type="text" class="form-control" required>\n</div>\n</div>\n</div>\n<div class="col">\n<div class="mb-3 row">\n<label class="col-lg-2 col-md-6 col-sm-12 col-form-label">Price:</label>\n<div class="col-lg-10 col-md-6 col-sm-12">\n<input name="price" value="{{getPrice}}" type="number" class="form-control" required>\n</div>\n</div>\n</div>\n</div>\n<div class="row">\n<div class="col">\n<div class="mb-3 row">\n<label class="col-lg-2 col-md-6 col-sm-12 col-form-label">Image:</label>\n<div class="col-lg-10 col-md-6 col-sm-12">\n<input class="form-control" type="file" name="image">\n</div>\n</div>\n</div>\n<div class="col">\n&nbsp;\n</div>\n</div>\n<div class="mb-3">\n<label class="form-label">Description</label>\n            <textarea class="form-control" name="description" rows="3" required>{{getDescription}}</textarea>\n</div>\n<button type="submit" class="btn btn-primary">Edit</button>\n</form>\n{{/with}}\n</div>\n</div>\n{{/inline}}\n{{/admin}}\nThe previous view is like the form created in the admin/products/index view but with minor differences. We pass\nthe product  id  to the route and populate the input values with the product attributes.\n',
      page_no: 69,
    },
    {
      id: 86,
      bookId: 33,
      content:
        "Running the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/admin/products”) route, click an edit button of a specific product, and you will see the edit form\n(see Fig. 20-2). Now, you can edit products. We suggest editing all products to replace the missing images (see Fig.\n20-3).\nFigure 20-2. Editing a product.\nFigure 20-3. List products with proper images.\n",
      page_no: 70,
    },
    {
      id: 87,
      bookId: 33,
      content:
        "Chapter 21 – Create Users\nIn this chapter, we will create users. We will split it into three parts: (i) User Entity, (ii) Users Service, and (iii)\nAuth Module.\nLet’s start by implementing the User entity.\nUser Entity\nCreating User Entity\nIn src/models , create a new file called user.entity.ts , and fill it with the following code.\nAdd Entire Code\nimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n@Entity()\nexport class User {\n@PrimaryGeneratedColumn()\nid: number;\n@Column()\nname: string;\n@Column({ unique: true })\nemail: string;\n@Column()\npassword: string;\n@Column()\nrole: string;\n@Column()\nbalance: number;\ngetId(): number {\nreturn this.id;\n}\nsetId(id: number) {\nthis.id = id;\n}\ngetName(): string {\nreturn this.name;\n}\nsetName(name: string) {\nthis.name = name;\n}\ngetEmail(): string {\nreturn this.email;\n}\nsetEmail(email: string) {\nthis.email = email;\n}\ngetPassword(): string {\nreturn this.password;\n}\nsetPassword(password: string) {\nthis.password = password;\n}\ngetRole(): string {\nreturn this.role;\n}\n",
      page_no: 71,
    },
    {
      id: 88,
      bookId: 33,
      content:
        "setRole(role: string) {\nthis.role = role;\n}\ngetBalance(): number {\nreturn this.balance;\n}\nsetBalance(balance: number) {\nthis.balance = balance;\n}\n}\nWe have defined a User  entity (which becomes a user table) with six attributes ( id , name ,  email , password ,\nrole , and balance ). For email  attribute, we applied the @Column  decorator with the unique  option set to true\nbecause user emails must be unique. We have two different roles client  and admin  (we will manage roles in an\nupcoming chapter). The balance attribute represents the amount of money that the user has in the application (we\nwill work with this later). Finally, we have the attributes getters and setters.\nSynchronizing the database\nLet’s synchronize our database. First, stop the server. Then, In the Terminal, go to the project directory, and\nexecute the following:\nExecute in Terminal\nnpm run start:dev\nNow, you can see the user  table in your online_store  database (see Fig. 21-1).\nFigure 21-1. New user table – phpMyAdmin.\nUsers Service\nInstalling bcrypt\nUsers will have passwords. We can’t store the passwords as plain text in our database as that is a critical risk.\nHackers could steal our database information and have full access to users’ passwords. In our case, we will use a\nlibrary called bcrypt which allows us to hash our passwords. More information about bcrypt can be found here:\nhttps://www.npmjs.com/package/bcrypt.\nHashing is the process of converting a given key into another value. A hash function is used to generate the new\nvalue according to a mathematical algorithm. Once hashing has been applied to a password, it should be reverse-\nengineer the hashed value to the original text.\nLet’s install bcrypt in our Online Store project. Go to the project directory, and in the Terminal, execute the\nfollowing commands.\nExecute in Terminal\nnpm install bcrypt\nnpm install -D @types/bcrypt\nCreating UsersService\nIn src/models , create a new file called users.service.ts , and fill it with the following code.\nAdd Entire Code\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { User } from './user.entity';\nimport * as bcrypt from 'bcrypt';\n",
      page_no: 72,
    },
    {
      id: 89,
      bookId: 33,
      content:
        "@Injectable()\nexport class UsersService {\nconstructor(\n@InjectRepository(User)\nprivate usersRepository: Repository<User>,\n) {}\nasync createOrUpdate(user: User): Promise<User> {\nconst hash = await bcrypt.hash(user.getPassword(), 10);\nuser.setPassword(hash);\nreturn this.usersRepository.save(user);\n}\n}\nWe define the UsersService  class, which injects a TypeORM User Repository instance in the usersRepository\nattribute to access the database. Then, we define the createOrUpdate  method. This method receives a  User\ninstance, collects the user password , and uses bcrypt.hash  to generate a hash (based on the user password  and\n10  salt rounds). Then we set the new password (the hashed version), and invoke this.usersRepository.save  to\ncreate the user in the database.\nAuth Module\nThe AuthModule  will manage all the actions related to authentication, such as login, registration, and logout. In\nthis chapter, we implement user registration which requires us to define a new module, a controller, and a view.\nLet’s start this process.\nCreating AuthController\nIn src/ , create a subfolder called auth . Then, in src/auth  create a new file called auth.controller.ts  and fill it\nwith the following code.\nAdd Entire Code\nimport { Controller, Get, Render, Post, Redirect, Body } from '@nestjs/common';\nimport { User } from 'src/models/user.entity';\nimport { UsersService } from '../models/users.service';\n@Controller('/auth')\nexport class AuthController {\nconstructor(private readonly usersService: UsersService) {}\n@Get('/register')\n@Render('auth/register')\nregister() {\nconst viewData = [];\nviewData['title'] = 'User Register - Online Store';\nviewData['subtitle'] = 'User Register';\nreturn {\nviewData: viewData,\n};\n}\n@Post('/store')\n@Redirect('/')\nasync store(@Body() body) {\nconst newUser = new User();\nnewUser.setName(body.name);\nnewUser.setPassword(body.password);\nnewUser.setEmail(body.email);\nnewUser.setRole('client');\nnewUser.setBalance(1000);\nawait this.usersService.createOrUpdate(newUser);\n}\n}\nWe define the AuthController  class with two methods.\nWe have a simple register  method linked to the (“/auth/register”) route that displays the views/auth/register.hbs\nview. This view will contain a form to create new users.\nWe have a store  method linked to the (“/auth/store”) route which redirects to the (“/”) route. This method will be\ninvoked once someone completes the form defined in the views/auth/register.hbs  view. We create a new  User\ninstance, set the user name , email , and password based on the values collected from the form and assigned it to\nthe body  variable. We also set a default user role ( client ), and a default user balance ( 1000 ). This means that the\n",
      page_no: 73,
    },
    {
      id: 90,
      bookId: 33,
      content:
        'user will have 1000 dollars to spend in our application. Finally, we invoke the usersService.createOrUpdate\nmethod with newUser  to create the new user in the database.\nAuth register view\nIn views/ , create a subfolder called auth . Then, in views/auth , create a new file called register.hbs , and fill it\nwith the following code.\nAdd Entire Code\n{{#> app}}\n{{#*inline "content"}}\n<div class="container">\n<div class="row justify-content-center">\n<div class="col-md-8">\n<div class="card">\n<div class="card-header">Register</div>\n<div class="card-body">\n<form method="POST" action="/auth/store">\n<div class="form-group row">\n<label for="name" class="col-md-4 col-form-label text-md-right">Name</label>\n<div class="col-md-6 pb-2">\n<input id="name" type="text" class="form-control" name="name" required />\n</div>\n</div>\n<div class="form-group row">\n<label for="email" class="col-md-4 col-form-label text-md-right">Email</label>\n<div class="col-md-6 pb-2">\n<input id="email" type="email" class="form-control" name="email" required />\n</div>\n</div>\n<div class="form-group row">\n<label for="password" class="col-md-4 col-form-label text-md-right">Password</label>\n<div class="col-md-6 pb-2">\n                    <input id="password" type="password" class="form-control" name="password" required />\n</div>\n</div>\n<div class="form-group row mb-0">\n<div class="col-md-6 offset-md-4">\n<button type="submit" class="btn bg-primary text-white">Register</button>\n</div>\n</div>\n</form>\n</div>\n</div>\n</div>\n</div>\n</div>\n{{/inline}}\n{{/app}}\nWe define a form to collect the user name , email , and password . Once submitted, this form invokes the\n(“auth/store”) route.\nUpdating link in app layout\nNow that we have the proper register route, let’s include it in the app  layout. In views/layouts/app.hbs , make the\nfollowing changes in bold.\nModify Bold Code\n<!doctype html>\n…\n<div class=”navbar-nav ms-auto”>\n<a class=”nav-link active” href=”/”>Home</a>\n<a class=”nav-link active” href=”/products”>Products</a>\n<a class="nav-link active" href="/about">About</a>\n<div class="vr bg-white mx-2 d-none d-lg-block"></div>\n<a class="nav-link active" href="/auth/register">Register</a>\n</div>\n...\nCreating Auth Module\nIn src/auth  create a new file auth.module.ts  and fill it with the following code.\n',
      page_no: 74,
    },
    {
      id: 91,
      bookId: 33,
      content:
        "Add Entire Code\nimport { Module } from '@nestjs/common';\nimport { AuthController } from './auth.controller';\n@Module({\ncontrollers: [AuthController],\n})\nexport class AuthModule {}\nWe created AuthModule  and registered AuthController .\nRegistering AuthModule, User, and UsersService in AppModule\nLet’s register the AuthModule , User , and UsersService  in the application root module ( AppModule ). In\nsrc/app.module.ts , make the following changes in bold.\nModify Bold Code\n…\nimport { ProductsService } from './models/products.service';\nimport { UsersService } from './models/users.service';\nimport { Product } from './models/product.entity';\nimport { User } from './models/user.entity';\nimport { AdminModule } from './admin/admin.module';\nimport { AuthModule } from './auth/auth.module';\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\nTypeOrmModule.forFeature([Product, User]),\nAdminModule,\nAuthModule,\n],\ncontrollers: [AppController, ProductsController],\nproviders: [ProductsService, UsersService],\nexports: [ProductsService, UsersService],\n})\nexport class AppModule {}\nWe import AuthModule  and register it in the module  imports  property. This import gives access to the routes\ndefined in AuthController . We also imported and configured the UsersService  and the User entity. It makes\nUsersService and the TypeORM User Repository  available to be injected across all modules.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/auth/register”) route, and you will see the registration form (see Fig. 21-2). Then, create a new\nuser. You will be redirected to the home page, and if you check your database, you will find the new record (see\nFig. 21-3).\nFigure 21-2. Online Store – Registration form.\n",
      page_no: 75,
    },
    {
      id: 92,
      bookId: 33,
      content: "Figure 21-3. New user row – phpMyAdmin.\n",
      page_no: 76,
    },
    {
      id: 93,
      bookId: 33,
      content:
        "Chapter 22 – Login System\nNow that users can create accounts, we need to implement a login system. This process requires a series of steps\nand the use of some new libraries. So, let’s begin.\nIntroduction to express-session library\nFor now, we have relied on the HTTP protocol to communicate with our Online Store. For example, if we want to\nget \nproducts’ \ninformation, \nwe \naccess \nhttp://localhost:3000/products. \nTo \nlog \nin, \nwe \naccess\nhttp://localhost:3000/auth/login. Each of our requests uses the HTTP protocol as a means of communication.\nHowever, the HTTP protocol has some limitations. HTTP is a stateless protocol, meaning that the server does not\nkeep any data (state) between two requests. In HTTP, every request creates a new connection, and each new request\nknows nothing about any prior requests. That is, it holds no state data.\nThere are multiple ways of holding state data. Nest suggests using the express-session library\n(https://github.com/expressjs/session). This library provides a way to store information about the user across\nmultiple requests, which is particularly useful for MVC applications.\nInstalling express-session\nLet’s install express-session in our Online Store project. Go to the project directory, and in the Terminal, execute\nthe following commands.\nExecute in Terminal\nnpm install express-session\nnpm install -D @types/express-session\nConfiguring express-session\nWe need to configure the Nest application to use express-session. In src/main.ts , make the following changes in\nbold.\nModify Bold Code\n…\nimport * as hbs from 'hbs';\nimport * as hbsUtils from 'hbs-utils';\nimport * as session from 'express-session';\nasync function bootstrap() {\n...\napp.setViewEngine('hbs');\napp.use(\nsession({\nsecret: 'nest-book',\nresave: false,\nsaveUninitialized: false,\n}),\n);\napp.use(function (req, res, next) {\nres.locals.session = req.session;\nnext();\n});\nawait app.listen(3000);\n}\nbootstrap();\nLet’s analyze the code by parts.\nAnalyze Code\napp.use(\nsession({\nsecret: 'nest-book',\nresave: false,\nsaveUninitialized: false,\n}),\n);\nWe import the express-session library, and configure our Nest Express application to use sessions. This\nconfiguration requires defining a secret . The secret  is used to sign a session ID cookie stored in the user’s\nbrowser and serves to identify the user accessing the application. The  secret is just a string. You can define your\nown secret . Enabling the resave option forces the session to be saved back to the session store, even if the session\n",
      page_no: 77,
    },
    {
      id: 94,
      bookId: 33,
      content:
        "was never modified during the request. Likewise, enabling the saveUninitialized  option forces a session that is\n\"uninitialized\" to be saved to the store. A session is uninitialized when it is new but not modified. We place both\noptions on false  since it will help to reduce server storage usage.\nWARNING: The express-session library uses a lightweight memory store mechanism by default. It\nstores the session information in a MemoryStore  instance. MemoryStore  is purposely not designed\nfor a production environment. It will leak memory under most conditions, does not scale past a\nsingle process, and is meant for debugging and developing. Thus, session data is not persisted\nacross server restarts. If you run your application, and you modify code and save it, the session\ndata will be lost. You can find session stores alternatives in the following link:\nhttps://github.com/expressjs/session#compatible-session-stores.\nAnalyze Code\napp.use(function (req, res, next) {\nres.locals.session = req.session;\nnext();\n});\nThe previous code defines an express middleware. A middleware is a function that has access to the request object\n( req ), the response object ( res ), and the next middleware function in the application’s request-response cycle.\nCommonly, middleware functions are used to execute code and make changes to the request and the response\nobjects. Let’s see what we are doing with the previous middleware.\nres.locals  is an object that contains response local variables scoped to the request, and therefore available only to\nthe view(s) rendered during that request/response cycle. In this case, we are extending the res.locals attribute by\nincluding a new attribute called res.locals.session , which will use the sessions values of the current request\n( req.session ). With the implementation of this middleware, we can access the sessions’ values from all Handlebars\nviews (we will use it later). We then invoke the next middleware ( next() ).\nLogin implementation\nNow that we have express-session library installed and configured, let’s implement the login system.\nModifying UsersService\nIn src/models/users.service.ts , make the following changes in bold.\nModify Bold Code\n...\n@Injectable()\nexport class UsersService {\n...\nasync login(email: string, password: string): Promise<User> {\nconst user = await this.usersRepository.findOne({ email: email });\nif (user) {\nconst isMatch = await bcrypt.compare(password, user.getPassword());\nif (isMatch) {\nreturn user;\n}\n}\nreturn null;\n}\n}\nWe include a login  method. This method receives an email and a password and returns a Promise consisting of a\nUser . First, we search for a user using this.usersRepository.findOne  based on the received email . If a user is\nfound, we use the bcrypt.compare  function to validate that the received password matches the password stored in\nthe database. If they match, we return the user  instance. Otherwise, return null .\nModifying AuthController\nIn src/auth/auth.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Post, Redirect, Body,\nReq, Res } from '@nestjs/common';\n…\n@Controller('/auth')\nexport class AuthController {\n…\n",
      page_no: 78,
    },
    {
      id: 95,
      bookId: 33,
      content:
        "@Get('/login')\n@Render('auth/login')\nlogin() {\nconst viewData = [];\nviewData['title'] = 'User Login - Online Store';\nviewData['subtitle'] = 'User Login';\nreturn {\nviewData: viewData,\n};\n}\n@Post('/connect')\nasync connect(@Body() body, @Req() request, @Res() response) {\nconst email = body.email;\nconst pass = body.password;\nconst user = await this.usersService.login(email, pass);\nif (user) {\nrequest.session.user = {\nid: user.getId(),\nname: user.getName(),\nrole: user.getRole(),\n};\nreturn response.redirect('/');\n} else {\nreturn response.redirect('/auth/login');\n}\n}\n@Get('/logout')\n@Redirect('/')\nlogout(@Req() request) {\nrequest.session.user = null;\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\n@Get('/login')\n@Render('auth/login')\nlogin() {\nconst viewData = [];\nviewData['title'] = 'User Login - Online Store';\nviewData['subtitle'] = 'User Login';\nreturn {\nviewData: viewData,\n};\n}\nWe define a  login method linked to the (“auth/login”) route which renders the auth/login view. This view\ncontains a form where the user enters the email and password information to log in.\nAnalyze Code\n@Post('/connect')\nasync connect(@Body() body, @Req() request, @Res() response) {\nconst email = body.email;\nconst pass = body.password;\nconst user = await this.usersService.login(email, pass);\nif (user) {\nrequest.session.user = {\nid: user.getId(),\nname: user.getName(),\nrole: user.getRole(),\n};\nreturn response.redirect('/');\n} else {\nreturn response.redirect('/auth/login');\n}\n}\nThe connect  method uses the imported Req  and Res  decorators to access the express request  and response\nobjects respectively. The connect method is invoked once the user accesses the (“auth/login”) route and completes\nthe login form. In this method, we collect the email and password  information (sent by the application user) and\npass that information to the this.usersService.login  method (which returns a user  instance if the login information\nis correct). If user is null , we redirect the application user to the (“/auth/login”) route to log in again. Otherwise,\nlogin is successful and we populate the request.session  with a new data ( user ). We store the user id , name , and\nrole  in the session. This information will be critical to know if the user is logged or not. Then, we redirect to the\nhome page.\n",
      page_no: 79,
    },
    {
      id: 96,
      bookId: 33,
      content:
        'Analyze Code\n@Get(\'/logout\')\n@Redirect(\'/\')\nlogout(@Req() request) {\nrequest.session.user = null;\n}\nWe then have the logout method which destroys the user information stored in the session (in the\nrequest.session.user  variable) and redirects to the home page.\nCreating auth/login view\nIn views/auth , create a new file called login.hbs and fill it with the following code.\nAdd Entire Code\n{{#> app}}\n{{#*inline "content"}}\n<div class="container">\n<div class="row justify-content-center">\n<div class="col-md-8">\n<div class="card">\n<div class="card-header">Login</div>\n<div class="card-body">\n<form method="POST" action="/auth/connect">\n<div class="form-group row pb-2">\n<label for="email" class="col-md-4 col-form-label text-md-right">Email</label>\n<div class="col-md-6">\n<input id="email" type="email" class="form-control" name="email" required />\n</div>\n</div>\n<div class="form-group row pb-2">\n<label for="password" class="col-md-4 col-form-label text-md-right">Password</label>\n<div class="col-md-6">\n<input id="password" type="password" class="form-control" name="password" required />\n</div>\n</div>\n<div class="form-group row mb-0">\n<div class="col-md-8 offset-md-4">\n<button type="submit" class="btn bg-primary text-white">\nLogin\n</button>\n</div>\n</div>\n</form>\n</div>\n</div>\n</div>\n</div>\n</div>\n{{/inline}}\n{{/app}}\nWe define a login view that collects the user’s email  and password . Once submitted, this form invokes the\n(“auth/connect”) route.\nUpdating links in app layout\nNow that we have the proper login and logout routes, let’s include them in the app  layout. In\nviews/layouts/app.hbs , make the following changes in bold.\nModify Bold Code\n<!doctype html>\n…\n<div class=”navbar-nav ms-auto”>\n<a class=”nav-link active” href=”/”>Home</a>\n<a class=”nav-link active” href=”/products”>Products</a>\n<a class="nav-link active" href="/about">About</a>\n<div class="vr bg-white mx-2 d-none d-lg-block"></div>\n{{#if session.user}}\n<a class="nav-link active" href="/auth/logout">Logout ({{session.user.name}})</a>\n{{else}}\n<a class="nav-link active" href="/auth/login">Login</a>\n<a class="nav-link active" href="/auth/register">Register</a>\n{{/if}}\n</div>\n...\n',
      page_no: 80,
    },
    {
      id: 97,
      bookId: 33,
      content:
        "We use the  if  helper in hbs to verify if we have user data in the session. If that is true, we display a Logout  link\nwith the name of the logged in user. Otherwise, we display the Login  and Register links. If the user clicks the\nLogout  link, the session data will be destroyed and thus is ‘logged out’.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/auth/login”) route, and you will see the login form (see Fig. 22-1). Login with an existing user\naccount. You will be redirected to the home page and see the Logout link with your name (see Fig. 22-2).\nFigure 22-1. Online Store – Login form.\nFigure 22-2. Online Store – Home page for a logged user.\nNow that we have learned to use the express-session library, it’s time to implement application validations.\n",
      page_no: 81,
    },
    {
      id: 98,
      bookId: 33,
      content:
        "Chapter 23 – Validations\nCurrently, we are only validating our application in the client-side (using some HTML elements, such as  required\nor input type email ). Those elements can be easily accessed and hacked. So, we will implement proper validations\nin our back-end code.\nIntroduction to Validator library\nWe can create our own validations, such as a function to validate that an email field contains an @ and a domain.\nHowever, we are not going to re-invent the wheel. We will use a JavaScript library called validator .\nValidator is a library of string validators and sanitizers (https://github.com/validatorjs/validator.js). It provides\nfunctions to check data received from different forms (such as isEmail , isEmpty , and isInt ).\nQuick discussion: Nest official documentation suggests using ValidationPipe , class-validator ,\nand class-transformer  for validations (https://docs.nestjs.com/techniques/validation). The\nproblem is that most Nest documentation is oriented to developing of applications that use\nservice-oriented architectures (specifically APIs). But we are developing applications that use\nMVC architectures. The Nest validators don’t work well with MVC applications. That is why\nwe use the validator library.\nInstalling Validator\nLet’s install the validator library in our Online Store project. Go to the project directory, and in the Terminal,\nexecute the following commands.\nExecute in Terminal\nnpm install validator\nProduct Validator\nLet’s use the validator library to create our product validator. First, in src  folder, create a subfolder called\nvalidators . Then, in src/validators , create a new file called product.validator.ts , and fill it with the following\ncode.\nAdd Entire Code\nimport validator from 'validator';\nexport class ProductValidator {\nstatic imageWhiteList: string[] = [\n'image/png',\n'image/jpeg',\n'image/jpg',\n'image/webp',\n];\nstatic validate(body, file: Express.Multer.File, toValidate: string[]) {\nconst errors: string[] = [];\nif (toValidate.includes('name') && validator.isEmpty(body.name)) {\nerrors.push('Product name cannot be empty');\n}\nif (\ntoValidate.includes('description') &&\nvalidator.isEmpty(body.description)\n) {\nerrors.push('Product description cannot be empty');\n}\nif (\ntoValidate.includes('price') &&\n!validator.isInt(body.price, { min: 0 })\n) {\nerrors.push('Product price must be not negative');\n}\nif (toValidate.includes('imageCreate')) {\nif (file === undefined) {\nerrors.push('You must upload a product image');\n} else if (!ProductValidator.imageWhiteList.includes(file.mimetype)) {\n",
      page_no: 82,
    },
    {
      id: 99,
      bookId: 33,
      content:
        "errors.push('Invalid image format');\n}\n}\nif (toValidate.includes('imageUpdate')) {\nif (\nfile !== undefined &&\n!ProductValidator.imageWhiteList.includes(file.mimetype)\n) {\nerrors.push('Invalid image format');\n}\n}\nreturn errors;\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\nimport validator from 'validator';\nexport class ProductValidator {\nstatic imageWhiteList: string[] = [\n'image/png',\n'image/jpeg',\n'image/jpg',\n'image/webp',\n];\nWe import the  validator  library and create a  ProductValidator  class. Then, we define an imageWhiteList  static\nattribute, which contains the list of valid MIME Types for our image files. A MIME type is a two-part identifier for\nfile formats and format contents transmitted on the Internet.\nAnalyze Code\nstatic validate(body, file: Express.Multer.File, toValidate: string[]) {\nconst errors: string[] = [];\nif (toValidate.includes('name') && validator.isEmpty(body.name)) {\nerrors.push('Product name cannot be empty');\n}\nif (\ntoValidate.includes('description') &&\nvalidator.isEmpty(body.description)\n) {\nerrors.push('Product description cannot be empty');\n}\nWe define a  validate  static method which is the heart of the product validations. This method contains three\narguments, body contains the information collected from the forms. file  contains the uploaded image, and\ntoValidate  is an array that contains a set of labels to determine which validations should be applied which makes\nour  validation  method more generic.\nThe previous code shows two validations. The first validation is executed if toValidate  contains the name  label.\nHere, we use the validator.isEmpty  method to verify if the body.name  is empty. If that is true, we include an error\nin the errors  variable. We validate  description  similarly.\nAnalyze Code\nif (\ntoValidate.includes('price') &&\n!validator.isInt(body.price, { min: 0 })\n) {\nerrors.push('Product price must be not negative');\n}\nFor price , we validate if body.price is int , and has a minimum value of 10 .\nAnalyze Code\nif (toValidate.includes('imageCreate')) {\nif (file === undefined) {\nerrors.push('You must upload a product image');\n} else if (!ProductValidator.imageWhiteList.includes(file.mimetype)) {\nerrors.push('Invalid image format');\n}\n}\n",
      page_no: 83,
    },
    {
      id: 100,
      bookId: 33,
      content:
        "if (toValidate.includes('imageUpdate')) {\nif (\nfile !== undefined &&\n!ProductValidator.imageWhiteList.includes(file.mimetype)\n) {\nerrors.push('Invalid image format');\n}\n}\nreturn errors;\nFor  image , we have two validations. First, if toValidate  includes the  imageCreate  label, we check if the file  is\nundefined , we include an error. Then, we check if file.mimetype  is included in the imageWhiteList attribute. If it\nis not, we include an error. In the second case, if toValidate  includes the  imageUpdate  label, we check that  file\nis not  undefined  and if file.mimetype  is not included in imageWhiteList , we include an error.\nIn the end, we return the errors variable. If its length is greater than zero, it means that some validations failed.\nModifying AdminProductsController\nIn src/admin/admin.products.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Post, Body, Redirect,\nUseInterceptors, UploadedFile, Param, Req } from '@nestjs/common';\nimport { FileInterceptor } from '@nestjs/platform-express';\nimport { ProductsService } from '../models/products.service';\nimport { Product } from '../models/product.entity';\nimport { ProductValidator } from '../validators/product.validator';\nimport * as fs from 'fs';\n@Controller('/admin/products')\nexport class AdminProductsController {\n...\n@Post('/store')\n@UseInterceptors(FileInterceptor('image', { dest: './public/uploads' }))\n@Redirect('/admin/products')\nasync store(@Body() body, @UploadedFile() file: Express.Multer.File,\n@Req() request,\n) {\nconst toValidate: string[] = ['name', 'description', 'price', 'imageCreate'];\nconst errors: string[] = ProductValidator.validate(body, file, toValidate);\nif (errors.length > 0) {\nif (file) {\nfs.unlinkSync(file.path);\n}\nrequest.session.flashErrors = errors;\n} else {\nconst newProduct = new Product();\nnewProduct.setName(body.name);\nnewProduct.setDescription(body.description);\nnewProduct.setPrice(body.price);\nnewProduct.setImage(file.filename);\nawait this.productsService.createOrUpdate(newProduct);\n}\n}\n…\nWe import the ProductValidator  class and the fs  library. The fs library enables interacting with the file system.\nWe then modify the store method. We include request  in the method arguments and create a  toValidate  array to\ndefine the validations we want to apply.  Then, we execute the ProductValidator.validate  method. If errors  are\nfound, we check if the image was uploaded, and in that case, we remove the image from the filesystem (using the\nfs.unlinkSync ). Besides, we set request.session.flashErrors  to contain the current errors . Finally, if no errors\nare found, we create and save the new product  into the database.\nModifying admin/products/index view\nIn views/admin/products/index.hbs , make the following changes in bold.\nModify Bold Code\n{{#> admin}}\n{{#*inline \"content\"}}\n<div class=\"card mb-4\">\n",
      page_no: 84,
    },
    {
      id: 101,
      bookId: 33,
      content:
        '<div class="card-header">\nCreate Products\n</div>\n<div class="card-body">\n{{#if flashErrors}}\n{{#each flashErrors}}\n<p class="alert alert-danger">{{this}}</p>\n{{/each}}\n{{/if}}\n<form method="POST" action="/admin/products/store"enctype="multipart/form-data">\n…\nWe include some paragraphs to show errors. We iterate through the flashErrors object and show its content.\nModifying main.ts\nIn src/main.ts , make the following changes in bold.\nModify Bold Code\n...\napp.use(function (req, res, next) {\nres.locals.session = req.session;\nconst flashErrors: string[] = req.session.flashErrors;\nif (flashErrors) {\nres.locals.flashErrors = flashErrors;\nreq.session.flashErrors = null;\n}\nnext();\n});\nawait app.listen(3000);\n}\nbootstrap();\nWe modify the middleware used to enable access to the session values from our hbs views. In this case, we create a\nflashErrors  array which contains the req.session.flashErrors . If there are flashErrors , we extend the res.locals\nproperty to contain the \nflashErrors  in the \nres.locals.flashErrors  property. Then, we destroy the\nreq.session.flashErrors  content.\nOur flash errors system work as flash messages. A flash message is a type of message that is created in a page,\ndisplay it once on another page (commonly, in a page that is called after a redirection), and then it disappears. Let’s\nsee them in action.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/admin/products”) route. Create a product with invalid data (i.e., price -21), and you will see the\nproper error messages (see Fig. 23-1). If you reload (or revisit) the page, you will see the messages disappear.\nFigure 23-1. Online Store – Creating a product with invalid data.\n',
      page_no: 85,
    },
    {
      id: 102,
      bookId: 33,
      content:
        "Other Validations\nLet’s complete other pending validations. Explanations will be short since they are similar to the previous\nvalidation.\nModifying AdminProductsController\nIn src/admin/admin.products.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Post, Body, Redirect,\nUseInterceptors, UploadedFile, Param, Req, Res } from '@nestjs/common';\nimport { FileInterceptor } from '@nestjs/platform-express';\n…\n@Controller('/admin/products')\nexport class AdminProductsController {\n...\n@Post('/:id/update')\n@UseInterceptors(FileInterceptor('image', { dest: './public/uploads' }))\n@Redirect('/admin/products')\nasync update(\n@Body() body,\n@UploadedFile() file: Express.Multer.File,\n@Param('id') id: string,\n@Req() request,\n@Res() response,\n) {\nconst toValidate: string[] = ['name', 'description', 'price', 'imageUpdate'];\nconst errors: string[] = ProductValidator.validate(body, file, toValidate);\nif (errors.length > 0) {\nif (file) {\nfs.unlinkSync(file.path);\n}\nrequest.session.flashErrors = errors;\nreturn response.redirect('/admin/products/'+id);\n} else {\nconst product = await this.productsService.findOne(id);\nproduct.setName(body.name);\nproduct.setDescription(body.description);\nproduct.setPrice(body.price);\nif (file) {\nproduct.setImage(file.filename);\n}\nawait this.productsService.createOrUpdate(product);\nreturn response.redirect('/admin/products/');\n}\n}\nWe modify the update  method. We remove the @Redirect  decorator since we will have two different\nredirections. We execute the product validations. In this case, we use the imageUpdate  label. If there are errors ,\nwe redirect to the (“/admin/products/:id”) route. If there are no errors, we update the product and redirect to the\n(“/admin/products/”) route.\nModifying admin/products/edit view\nIn views/admin/products/edit.hbs , make the following changes in bold.\nModify Bold Code\n{{#> admin}}\n{{#*inline \"content\"}}\n<div class=\"card mb-4\">\n<div class=\"card-header\">\nEdit Product\n</div>\n<div class=\"card-body\">\n{{#if flashErrors}}\n{{#each flashErrors}}\n<p class=\"alert alert-danger\">{{this}}</p>\n{{/each}}\n{{/if}}\n{{#with viewData.product}}\n…\nWe include the  flashErrors  object and iterate through it to show the errors.\n",
      page_no: 86,
    },
    {
      id: 103,
      bookId: 33,
      content:
        "Creating user validator\nIn src/validators , create a new file user.validator.ts , and fill it with the following code.\nAdd Entire Code\nimport validator from 'validator';\nexport class UserValidator {\nstatic validate(body, toValidate: string[]) {\nconst errors: string[] = [];\nif (toValidate.includes('name') && validator.isEmpty(body.name)) {\nerrors.push('Name cannot be empty');\n}\nif (toValidate.includes('email') && !validator.isEmail(body.email)) {\nerrors.push('Invalid Email format');\n}\nif (\ntoValidate.includes('password') &&\nvalidator.isEmpty(body.password)\n) {\nerrors.push('Password cannot be empty');\n}\nreturn errors;\n}\n}\nWe create a validate method with proper validations for name , password , and email . Note that for email , we\nuse the validator.isEmail .\nModifying AuthController\nIn src/auth/auth.controller.ts , make the following changes in bold.\nModify Bold Code\n…\nimport { UsersService } from '../models/users.service';\nimport { UserValidator } from '../validators/user.validator';\n@Controller('/auth')\nexport class AuthController {\n…\n@Post('/store')\n@Redirect('/')\nasync store(@Body() body, @Res() response, @Req() request) {\nconst toValidate: string[] = ['name', 'email', 'password'];\nconst errors: string[] = UserValidator.validate(body, toValidate);\nif (errors.length > 0) {\nrequest.session.flashErrors = errors;\nreturn response.redirect('/auth/register');\n} else {\nconst newUser = new User();\nnewUser.setName(body.name);\nnewUser.setPassword(body.password);\nnewUser.setEmail(body.email);\nnewUser.setRole('client');\nnewUser.setBalance(1000);\nawait this.usersService.createOrUpdate(newUser);\nreturn response.redirect('/auth/login');\n}\n}\nWe modify the  store method to execute the user validations. If there are errors , we direct to the (“/auth/register”)\nroute again. If there are none, we redirect the user to the (“/auth/login”) route.\nModifying auth/register view\nIn views/auth/register.hbs , make the following changes in bold.\nModify Bold Code\n{{#> app}}\n",
      page_no: 87,
    },
    {
      id: 104,
      bookId: 33,
      content:
        '{{#*inline "content"}}\n<div class="container">\n<div class="row justify-content-center">\n<div class="col-md-8">\n<div class="card">\n<div class="card-header">Register</div>\n<div class="card-body">\n{{#if flashErrors}}\n{{#each flashErrors}}\n<p class="alert alert-danger">{{this}}</p>\n{{/each}}\n{{/if}}\n<form method="POST" action="/auth/store">\nWe include flashErrors as usual.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow you can create and edit products (“/admin/products”) and the validations will be applied. Also, if you try to\nregister a user account (“/auth/register”), the proper validations will be applied and displayed.\n',
      page_no: 88,
    },
    {
      id: 105,
      bookId: 33,
      content:
        'Chapter 24 – Authorization\nCurrently, anyone can access the admin panel and create, edit, and delete products. In a real-world setting, this\nobviously shouldn’t be the way. So, let’s implement an authorization system.\nDefining admins\nIf you check your  user  table, you will see that all users are ‘clients’. We don’t have admins yet. So, let’s define an\nadmin. Go to phpMyAdmin, in the online_store  database, click the user  table, browse a specific user, and change\nthe user’s role  from  client  to admin  (Fig. 24-1).\nFigure 24-1. Editing a user’s role.\nNest Authorization\nNest provides an authorization mechanism called guards (https://docs.nestjs.com/guards). A guard is a class\nannotated with the @Injectable()  decorator which implements the CanActivate  interface. Guards have a single\nresponsibility. They determine whether a given request will be handled by the route handler or not depending on\ncertain conditions (like permissions, roles, etc.) present at run-time. This is often referred to as authorization.\nThe problem with guards (and other Nest mechanisms) is that they are designed for API applications. If we\nimplement Nest Guards, we will see code executions which result in pages showing JSON messages, such as the\nfollowing.\nAnalyze Code\n{\n"statusCode": 403,\n"message": "Forbidden resource",\n"error": "Forbidden"\n}\nThese kind of messages and executions are not designed for MVC applications.\nQuick discussion: At this point, we have the same problem we faced with Nest validations. We\ncannot use many of those libraries because they are not designed for MVC applications. Let’s\nhope that in the future, Nest documentation evolves and creators can support a little more in the\ndesign of MVC applications. Who knows, maybe this book can help a little in that process.\nDue to the previous issues, we will take another path and use express middleware instead to implement a solution.\nModifying main.ts\nIn src/main.ts , make the following changes in bold.\nModify Bold Code\n...\n});\napp.use(\'/admin*\', function (req, res, next) {\nif (req.session.user && req.session.user.role == \'admin\') {\nnext();\n} else {\nres.redirect(\'/\');\n}\n});\nawait app.listen(3000);\n}\nbootstrap();\nWe create a new middleware for routes that begins with the (“/admin”) string (all our admin routes). We check if\nthere is a req.session.user  property, and that it contains a role  property with admin value. If so, it means that the\ncurrent user is logged in as an admin and can access the current route. We then call the next()  method to continue\nto the next middleware. Otherwise, we redirect the user to the home page.\nQuick discussion: We implemented a simple authorization system. If you have a better solution,\n',
      page_no: 89,
    },
    {
      id: 106,
      bookId: 33,
      content:
        "feel free to use the discussion zone of this book’s repository to share it with us. We will learn\nfrom these discussions.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nIf you access the (“/admin”) route with a client user, you will be redirected to the home page. Now, log in to the\napplication with the credentials of an admin user. And if you access the (“/admin”) route, you will see the admin\npanel this time.\n",
      page_no: 90,
    },
    {
      id: 107,
      bookId: 33,
      content:
        "Chapter 25 – Shopping Cart\nNow that we have used express-sessions a couple of times, let’s implement the shopping cart system.\nCart Module\nThe CartModule  will manage all the actions related to the shopping cart, such as adding, removing, and checking\nproducts in the shopping cart. It requires defining a new module, controller, and view. Let’s begin.\nCreating CartController\nIn src/ , create a subfolder called cart . Then, in src/cart  create a new file called cart.controller.ts  and fill it with\nthe following code.\nAdd Entire Code\nimport { Controller, Get, Render, Req, Redirect, Param,\nBody, Post } from '@nestjs/common';\nimport { ProductsService } from '../models/products.service';\nimport { Product } from '../models/product.entity';\n@Controller('/cart')\nexport class CartController {\nconstructor(private readonly productsService: ProductsService) {}\n@Get('/')\n@Render('cart/index')\nasync index(@Req() request) {\nlet total = 0;\nlet productsInCart: Product[] = null;\nconst productsInSession = request.session.products;\nif (productsInSession) {\nproductsInCart = await this.productsService.findByIds(\nObject.keys(productsInSession),\n);\ntotal = Product.sumPricesByQuantities(productsInCart, productsInSession);\n}\nconst viewData = [];\nviewData['title'] = 'Cart - Online Store';\nviewData['subtitle'] = 'Shopping Cart';\nviewData['total'] = total;\nviewData['productsInCart'] = productsInCart;\nreturn {\nviewData: viewData,\n};\n}\n@Post('/add/:id')\n@Redirect('/cart')\nadd(@Param('id') id: number, @Body() body, @Req() request) {\nlet productsInSession = request.session.products;\nif (!productsInSession) {\nproductsInSession = {};\n}\nproductsInSession[id] = body.quantity;\nrequest.session.products = productsInSession;\n}\n@Get('/delete')\n@Redirect('/cart/')\ndelete(@Req() request) {\nrequest.session.products = null;\n}\n}\nLet’s analyze the code by parts.\nAnalyze Code\n@Post('/add/:id')\n@Redirect('/cart')\nadd(@Param('id') id: number, @Body() body, @Req() request) {\nlet productsInSession = request.session.products;\nif (!productsInSession) {\nproductsInSession = {};\n}\nproductsInSession[id] = body.quantity;\n",
      page_no: 91,
    },
    {
      id: 108,
      bookId: 33,
      content:
        "request.session.products = productsInSession;\n}\nThe  add  method receives the inputs (quantity of product) collected from the form in the body argument, and the\nid  of the product to be added in the cart. Then, we get the products stored in the session through the\nrequest.session.products property. The first time, request.session.products won’t exist, so we assign it to an empty\nobject. Next, we include in productsInSession variable the collected product id  (as a key) with its quantity  (as the\ncorresponding value). We then update the products stored in the session. Finally, the @Redirect  decorator\nredirects the user to the (“/cart”) route.\nAnalyze Code\n@Get('/delete')\n@Redirect('/cart/')\ndelete(@Req() request) {\nrequest.session.products = null;\n}\nThe  delete  method receives the  request , and removes the products stored in the session associated to that request.\nThen, we redirect to the (“/cart”) route.\nAnalyze Code\n@Get('/')\n@Render('cart/index')\nasync index(@Req() request) {\nlet total = 0;\nlet productsInCart: Product[] = null;\nconst productsInSession = request.session.products;\nif (productsInSession) {\nproductsInCart = await this.productsService.findByIds(\nObject.keys(productsInSession),\n);\ntotal = Product.sumPricesByQuantities(productsInCart, productsInSession);\n}\nconst viewData = [];\nviewData['title'] = 'Cart - Online Store';\nviewData['subtitle'] = 'Shopping Cart';\nviewData['total'] = total;\nviewData['productsInCart'] = productsInCart;\nreturn {\nviewData: viewData,\n};\n}\nThe  index  method defines a total variable with a zero value and an empty productsInCart  array. First, we check\nif the current request  has products stored in session. If there are productsInSession , we extract the related\nproducts from the database. In this case, we use the model findByIds method, which receives an array with primary\nkeys \nand \nreturns \nan \narray \nof \nproducts \n(this \nmethod \nwill \nbe \nimplemented \nlater). \nWe \nsend\nObject.keys(productsInSession)  to this method (remember we store the products id as keys and the quantities of the\nproducts as values). Then, we update the total  value by invoking the Product.sumPricesByQuantities  method\n(which will be implemented next). Finally, we send the total  and productsInCart  to the cart/index  view.\nModifying Product Entity\nIn src/models/product.entity.ts , make the following changes in bold.\nModify Bold Code\n...\nsetPrice(price: number) {\nthis.price = price;\n}\nstatic sumPricesByQuantities(products: Product[], productsInSession): number {\nlet total = 0;\nfor (let i = 0; i < products.length; i++) {\ntotal =\ntotal + products[i].getPrice() * productsInSession[products[i].getId()];\n}\nreturn total;\n}\n}\nWe includ a new static method called sumPricesByQuantities . sumPricesByQuantities  receives an array of\nproducts and the products stored in session. It iterates over the products and calculates the total to be paid (based\non the price  of each product and its corresponding quantity ). It then returns the total  to be paid.\n",
      page_no: 92,
    },
    {
      id: 109,
      bookId: 33,
      content:
        "TIP: We have designed an architecture where models are separated into two parts: entities and\nservices. We use entities to store our classes information and operations related to those classes\n(that’s why we include sumPricesByQuantities  method in our Product entity file). And we use\nservices to group all the database operations. Having this in mind, it will be easier for you to\norganize your code.\nModifying Products Service\nIn src/models/products.service.ts , make the following changes in bold.\nModify Bold Code\n...\n@Injectable()\nexport class ProductsService {\n...\nfindOne(id: string): Promise<Product> {\nreturn this.productsRepository.findOne(id);\n}\nfindByIds(ids: string[]): Promise<Product[]> {\nreturn this.productsRepository.findByIds(ids);\n}\n...\nThe  findByIds  method receives an array of strings ( ids )  and returns a Promise consisting of an array of products.\nThis method uses the productsRepository  attribute, which invokes the  findByIds  method (inherited from the\nTypeORM Repository  class). It takes the array of  ids , and returns the corresponding products based on those ids .\nCreating Cart Module\nIn src/cart  create a new file called cart.module.ts  and fill it with the following code.\nAdd Entire Code\nimport { Module } from '@nestjs/common';\nimport { CartController } from './cart.controller';\n@Module({\ncontrollers: [CartController],\n})\nexport class CartModule {}\nWe created CartModule  and registered CartController .\nModifying AppModule\nLet’s register CartModule  in the application root module ( AppModule ). In src/app.module.ts , make the\nfollowing changes in bold.\nModify Bold Code\n…\nimport { AuthModule } from './auth/auth.module';\nimport { CartModule } from './cart/cart.module';\n@Global()\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\nTypeOrmModule.forFeature([Product, User]),\nAdminModule,\nAuthModule,\nCartModule,\n],\n…\nCart index view\nIn views/ , create a subfolder called cart . In views/cart  create a new file index.hbs  and fill it with the following\ncode.\nAdd Entire Code\n{{#> app}}\n{{#*inline \"content\"}}\n<div class=\"card\">\n",
      page_no: 93,
    },
    {
      id: 110,
      bookId: 33,
      content:
        '<div class="card-header">\nProducts in Cart\n</div>\n<div class="card-body">\n<table class="table table-bordered table-striped text-center">\n<thead>\n<tr>\n<th scope="col">ID</th>\n<th scope="col">Name</th>\n<th scope="col">Price</th>\n<th scope="col">Quantity</th>\n</tr>\n</thead>\n<tbody>\n{{#each viewData.productsInCart}}\n<tr>\n<td>{{getId}}</td>\n<td>{{getName}}</td>\n<td>${{getPrice}}</td>\n<td>{{lookup ../session.products id}}</td>\n</tr>\n{{/each}}\n</tbody>\n</table>\n<div class="row">\n<div class="text-end">\n<a class="btn btn-outline-secondary mb-2"><b>Total to pay:</b> ${{viewData.total}}</a>\n<a class="btn bg-primary text-white mb-2">Purchase</a>\n<a href="/cart/delete" class="btn btn-danger mb-2">\nRemove all products from Cart\n</a>\n</div>\n</div>\n</div>\n</div>\n{{/inline}}\n{{/app}}\nThis view is like the admin/products/index  view. We iterate and display the products added in session. We also use\nthe session  hbs object to access the products’ quantities. Since the  session  object is outside the  each scope, we\nmust use the “../”. In theory we can access the products quantities through this form ../session.products.[getID] .\nBut handlebars is very restrictive. So, we need to use the lookup  helper which allows for dynamic parameter\nresolution. This helper doesn’t allow us to use getId , so we use the id variable to access product id  and extract\nthe quantity. Finally, we display the total  to be paid, a purchase button (which doesn’t do anything yet), and a\nbutton to remove all products from the cart linking the (“/cart/delete”) route.\nModifying the products/show view\nIn views/products/show.hbs , make the following changes in bold.\nModify Bold Code\n...\n<div class="card-body">\n<h5 class="card-title">\n{{getName}} (${{getPrice}})\n</h5>\n<p class="card-text">{{getDescription}}</p>\n<p class="card-text"><small class="text-muted">Add to Cart</small></p>\n<p class="card-text">\n<form method="POST" action="/cart/add/{{getId}}">\n<div class="row">\n<div class="col-auto">\n<div class="input-group col-auto">\n<div class="input-group-text">Quantity</div>\n                      <input type="number" min="1" max="10" class="form-control quantity-input" name="quantity" value="1">\n</div>\n</div>\n<div class="col-auto">\n<button class="btn bg-primary text-white" type="submit">Add to cart</button>\n</div>\n</div>\n</form>\n</p>\n</div>\n...\nWe add a new form where the user enters the product’s quantity to the cart. This form is linked to the\n(“/cart/add/:id”) route.\n',
      page_no: 94,
    },
    {
      id: 111,
      bookId: 33,
      content:
        'Updating link in app layout\nNow that we have the proper cart route, let’s include it in the app  layout. In views/layouts/app.hbs , make the\nfollowing changes in bold.\nModify Bold Code\n<!doctype html>\n…\n<div class=”navbar-nav ms-auto”>\n<a class=”nav-link active” href=”/”>Home</a>\n<a class=”nav-link active” href=”/products”>Products</a>\n<a class="nav-link active" href="/cart">Cart</a>\n<a class="nav-link active" href="/about">About</a>\n<div class="vr bg-white mx-2 d-none d-lg-block"></div>        \n...\nWe added a new link to the cart page.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow go to the (“/products”) route, click a specific product, and you will see the new products/show  view (see Fig.\n25-1). Next, you can add some products to the cart and visit the (“/cart”) route. It will show you the total to be paid\nand a button to remove all products from the cart (see Fig. 25-2).\nFigure 25-1. Product show view with add to cart button.\n',
      page_no: 95,
    },
    {
      id: 112,
      bookId: 33,
      content: "Figure 25-2. Online Store – Shopping cart page.\n",
      page_no: 96,
    },
    {
      id: 113,
      bookId: 33,
      content:
        "Chapter 26 – Orders and Items\nTo complete our shopping cart, we must be able to make purchases. However, we need to set in place some things\nbefore adding the purchase functionality.\nOrders and Items\nLet’s take Fig. 26-1 as a base. Though a simplified invoice, it is helpful to show the data we need to store.\nFigure 26-1. Example of an invoice.\nFor the Order, we need to store:\n• Id: in the example, it is #1 .\n• Date: in the example, it is 2021-10-14 .\n• Total: in the example, it is $1060 .\n• User id: in the example, it is 1 .\n• User name: in the example, it is Daniel . Username won’t be stored since we can retrieve it with user id .\nOrders are composed of items (see the internal table in Fig. 26-1).  So, for each Item, we need to store:\n• Quantity: in the example, it is 1  for the first item. It means that the user is buying one TV.\n• Product id: in the example, it is 1 for the first item. It means that the user is buying the product with id 1 .\n• Product name: in the example, it is TV for the first item. Product name won’t be stored since we can retrieve\nit based on product id .\n• Price: in the example, it is 1000 for the first item. We will store this price since it is common for products to\nchange their price. Also, storing the price in the item table will allow us to know at which price the user bought\neach product.\n• Id: we will include the item  id  to trace each item.\nNow that we understand how these simplified invoices work, let’s create the proper entities.\nOrder Entity\nIn src/models  create a new file called order.entity.ts  and fill it with the following code.\nAdd Entire Code\nimport { Entity, Column, PrimaryGeneratedColumn, ManyToOne,\nOneToMany, CreateDateColumn } from 'typeorm';\nimport { User } from './user.entity';\nimport { Item } from './item.entity';\n@Entity()\nexport class Order {\n@PrimaryGeneratedColumn()\nid: number;\n@Column()\ntotal: number;\n@CreateDateColumn()\ndate: Date;\n",
      page_no: 97,
    },
    {
      id: 114,
      bookId: 33,
      content:
        "@ManyToOne(() => User, (user) => user.orders)\nuser: User;\n@OneToMany(() => Item, (item) => item.order)\nitems: Item[];\ngetId(): number {\nreturn this.id;\n}\nsetId(id: number) {\nthis.id = id;\n}\ngetTotal(): number {\nreturn this.total;\n}\nsetTotal(total: number) {\nthis.total = total;\n}\ngetDate(): Date {\nreturn this.date;\n}\nsetDate(date: Date) {\nthis.date = date;\n}\ngetUser(): User {\nreturn this.user;\n}\nsetUser(user: User) {\nthis.user = user;\n}\ngetItems(): Item[] {\nreturn this.items;\n}\nsetItems(items: Item[]) {\nthis.items = items;\n}\n}\nLet’s analyze the code by parts.\nThe Order  entity contains an  id , a total , a date , and two attributes ( user  and items ) representing relations to\nother entities. Let’s analyze the date , user  and items  in detail.\nAnalyze Code\n@CreateDateColumn()\ndate: Date;\nTypeORM provides a special column( CreateDateColumn ) that sets to the date attribute the entity’s insertion\ntime. Thus, we won’t need to set this attribute as it will be automatically set.\nAnalyze Code\n@ManyToOne(() => User, (user) => user.orders)\nuser: User;\nThe user  attribute is decorated with the @ManyToOne . @ManyToOne  indicates a relation where User contains\nmultiple instances of Orders , but  Order  contains only one User  instance. In our application, a user can create\nmultiple orders, but an order is only assigned to a specific user. The use of these decorators will create some foreign\nkeys in our database tables and allow us to navigate across our entities. For example, we will be able to extract the\nname of the user who completed a specific order with a piece of code like: order->getUser()->getName()  (we will\nsee an example later). We will add  orders  attribute to user  later.\nAnalyze Code\n@OneToMany(() => Item, (item) => item.order)\nitems: Item[];\n",
      page_no: 98,
    },
    {
      id: 115,
      bookId: 33,
      content:
        "Here we add @OneToMany  to the  items attribute (the inverse of @ManyToOne  decorator). An Item contains\nonly one instance of Order , but an Order contains multiple instances of Items . This is consistent with Fig. 26-1.\nMore information about TypeORM relations can be found here: https://typeorm.io/#/relations.\nAnalyze Code\ngetUser(): User {\nreturn this.user;\n}\nsetUser(user: User) {\nthis.user = user;\n}\ngetItems(): Item[] {\nreturn this.items;\n}\nsetItems(items: Item[]) {\nthis.items = items;\n}\nFinally, we have proper getters and setters to manage these attributes.\nModifying User Entity\nIn src/models/user.entity.ts , make the following changes in bold.\nModify Bold Code\nimport { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';\nimport { Order } from './order.entity';\n@Entity()\nexport class User {\n...\n@Column()\nbalance: number;\n@OneToMany(() => Order, (order) => order.user)\norders: Order[];\n...\ngetOrders(): Order[] {\nreturn this.orders;\n}\nsetOrders(orders: Order[]) {\nthis.orders = orders;\n}\n}\nWe import the Order entity and use it to define the orders attribute. Note that we use the @OneToMany\ndecorator since a User contains multiple Orders . Then, we define the proper getter and setter for the new\nattribute.\nItem Entity\nIn src/models  create a new file called item.entity.ts  and fill it with the following code.\nAdd Entire Code\nimport { Entity, Column, PrimaryGeneratedColumn, ManyToOne } from 'typeorm';\nimport { Order } from './order.entity';\nimport { Product } from './product.entity';\n@Entity()\nexport class Item {\n@PrimaryGeneratedColumn()\nid: number;\n@Column()\nquantity: number;\n",
      page_no: 99,
    },
    {
      id: 116,
      bookId: 33,
      content:
        "@Column()\nprice: number;\n@ManyToOne(() => Order, (order) => order.items)\norder: Order;\n@ManyToOne(() => Product, (product) => product.items)\nproduct: Product;\ngetId(): number {\nreturn this.id;\n}\nsetId(id: number) {\nthis.id = id;\n}\ngetQuantity(): number {\nreturn this.quantity;\n}\nsetQuantity(quantity: number) {\nthis.quantity = quantity;\n}\ngetPrice(): number {\nreturn this.price;\n}\nsetPrice(price: number) {\nthis.price = price;\n}\ngetOrder(): Order {\nreturn this.order;\n}\nsetOrder(order: Order) {\nthis.order = order;\n}\ngetProduct(): Product {\nreturn this.product;\n}\nsetProduct(product: Product) {\nthis.product = product;\n}\n}\nThe Item  entity contains an  id , a quantity , a price , and two attributes ( order  and product ) representing\nrelations to other entities. @ManyToOne  is used to decorate the order and product attributes since an Order\ncontains multiple Items , and a Product  contains multiple Items  too. And an Item  is only assigned to one Order\nand to one Product . We complete the Item  entity with getters and setters.\nModifying Product Entity\nIn src/models/product.entity.ts , make the following changes in bold.\nModify Bold Code\nimport { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';\nimport { Item } from './item.entity';\n@Entity()\nexport class Product {\n...\n@Column()\nprice: number;\n@OneToMany(() => Item, (item) => item.product)\nitems: Item[];\n",
      page_no: 100,
    },
    {
      id: 117,
      bookId: 33,
      content:
        "...\nsetPrice(price: number) {\nthis.price = price;\n}\ngetItems(): Item[] {\nreturn this.items;\n}\nsetItems(items: Item[]) {\nthis.items = items;\n}\n...\nWe import the Item entity and use it to define the items attribute. Note that we use the @OneToMany  decorator\nsince a Product contains multiple Items . Then, we define the proper getter and setter for the new attribute.\nAnalyzing class diagram\nFig. 26-2 shows our initial class diagram. We have implemented almost all the elements in that diagram.\n• We implemented all the classes (in the form of entities).\n• We implemented all the classes’ attributes.\n• We implemented all the classes’ associations.\n• We implemented all the classes’ getters and setters.\n• We implemented many CRUD methods (in the form of services). However, we will need to implement the\nOrder service later.\nFigure 26-2. Original Online Store class diagram.\nSynchronizing the database\nLet’s synchronize our database. First, stop the server. Then, In the Terminal, go to the project directory, and\nexecute the following:\nExecute in Terminal\nnpm run start:dev\nYou can see the new order and item  tables in your online_store  database (see Fig. 26-3).\n",
      page_no: 101,
    },
    {
      id: 118,
      bookId: 33,
      content:
        "Figure 26-3. New order and item tables – phpMyAdmin.\nNow, we are ready to implement the purchase system.\n",
      page_no: 102,
    },
    {
      id: 119,
      bookId: 33,
      content:
        "Chapter 27 – Product Purchase\nLet’s make some changes to implement the product purchase.\nModifying UsersService\nIn src/models/users.service.ts , make the following changes in bold.\nModify Bold Code\n...\n@Injectable()\nexport class UsersService {\n...\nfindOne(id: string): Promise<User> {\nreturn this.usersRepository.findOne(id);\n}\nupdateBalance(id: number, balance: number) {\nreturn this.usersRepository.update(id, {balance: balance});\n}\n}\nWe extend the UsersService  capabilities, by including a findOne  method that allows searching users by id . We\nalso include a updateBalance method that updates the user balance  based on the user id .\nCreating OrdersService\nIn src/models , create a new file called orders.service.ts , and fill it with the following code.\nAdd Entire Code\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Order } from './order.entity';\n@Injectable()\nexport class OrdersService {\nconstructor(\n@InjectRepository(Order)\nprivate ordersRepository: Repository<Order>,\n) {}\ncreateOrUpdate(order: Order): Promise<Order> {\nreturn this.ordersRepository.save(order);\n}\n}\nWe implement a OrdersService  class with a createOrUpdate  method to save an order  into the database.\nRegistering Order and OrdersService in AppModule\nLet’s register Order  and OrdersService  in the application root module ( AppModule ). In src/app.module.ts ,\nmake the following changes in bold.\nModify Bold Code\n…\nimport { UsersService } from './models/users.service';\nimport { OrdersService } from './models/orders.service';\nimport { Product } from './models/product.entity';\nimport { User } from './models/user.entity';\nimport { Order } from './models/order.entity';\nimport { AdminModule } from './admin/admin.module';\n…\n@Global()\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\nTypeOrmModule.forFeature([Product, User, Order]),\nAdminModule,\nAuthModule,\nCartModule,\n],\ncontrollers: [AppController, ProductsController],\n",
      page_no: 103,
    },
    {
      id: 120,
      bookId: 33,
      content:
        'providers: [ProductsService, UsersService, OrdersService],\nexports: [ProductsService, UsersService, OrdersService],\n})\nexport class AppModule {}\nWe imported and configured the OrdersService  and the Order entity. It will make the OrdersService and the\nTypeORM Order Repository  available to be injected across all modules.\nModifying Order Entity\nIn src/models/order.entity.ts , make the following changes in bold.\nModify Bold Code\n...\n@Entity()\nexport class Order {\n...\n@ManyToOne(() => User, (user) => user.orders)\nuser: User;\n@OneToMany(() => Item, (item) => item.order, {\ncascade: [\'insert\']\n})\nitems: Item[];\n...\nWe set the cascade  option to enable insert in the @OneToMany items  relation. This means that when we save\nthe order  instance, the array of items  of that order  will be saved too. We will illustrate this behavior later.\nModifying cart/index view\nIn views/cart/index.hbs , make the following changes in bold.\nModify Bold Code\n...\n<div class="row">\n<div class="text-end">\n<a class="btn btn-outline-secondary mb-2"><b>Total to pay:</b> ${{viewData.total}}</a>\n{{#if viewData.productsInCart}}\n<a href="/cart/purchase" class="btn bg-primary text-white mb-2">Purchase</a>\n<a href="/cart/delete" class="btn btn-danger mb-2">\nRemove all products from Cart\n</a>\n{{/if}}\n</div>\n</div>\n…\nWe modified the cart/index  view. We only show the Purchase  button and the “Remove all products from Cart”\nbutton if the user has products in session. And we link the Purchase  link with the (“cart/purchase”) route.\nCart purchase view\nIn views/cart , create a new file purchase.hbs  and fill it with the following code.\nAdd Entire Code\n{{#> app}}\n{{#*inline "content"}}\n<div class="card">\n<div class="card-header">\nPurchase Completed\n</div>\n<div class="card-body">\n<div class="alert alert-success" role="alert">\nCongratulations, purchase completed. Order number is <b>#{{viewData.orderId}}</b>\n</div>\n</div>\n</div>\n{{/inline}}\n{{/app}}\nIt is a simple view that displays a message and shows the order id. This view will be displayed when the user\ncompletes the purchase.\n',
      page_no: 104,
    },
    {
      id: 121,
      bookId: 33,
      content:
        "Modifying CartController\nIn src/cart/cart.controller.ts , make the following changes in bold.\nModify Bold Code\nimport { Controller, Get, Render, Req, Redirect, Param,\nBody, Post, Res } from '@nestjs/common';\nimport { ProductsService } from '../models/products.service';\nimport { OrdersService } from '../models/orders.service';\nimport { UsersService } from '../models/users.service';\nimport { Product } from '../models/product.entity';\nimport { Order } from '../models/order.entity';\nimport { Item } from '../models/item.entity';\n@Controller('/cart')\nexport class CartController {\nconstructor(\nprivate readonly productsService: ProductsService,\nprivate readonly usersService: UsersService,\nprivate readonly ordersService: OrdersService,\n) {}\n…\n@Get('/purchase')\nasync purchase(@Req() request, @Res() response) {\nif (!request.session.user) {\nreturn response.redirect('/auth/login');\n} else if (!request.session.products) {\nreturn response.redirect('/cart');\n} else {\nconst user = await this.usersService.findOne(request.session.user.id);\nconst productsInSession = request.session.products;\nconst productsInCart = await this.productsService.findByIds(\nObject.keys(productsInSession),\n);\nlet total = 0;\nconst items: Item[] = [];\nfor (let i = 0; i < productsInCart.length; i++) {\nconst quantity = productsInSession[productsInCart[i].getId()];\nconst item = new Item();\nitem.setQuantity(quantity);\nitem.setPrice(productsInCart[i].getPrice());\nitem.setProduct(productsInCart[i]);\nitems.push(item);\ntotal = total + productsInCart[i].getPrice() * quantity;\n}\nconst newOrder = new Order();\nnewOrder.setTotal(total);\nnewOrder.setItems(items);\nnewOrder.setUser(user);\nconst order = await this.ordersService.createOrUpdate(newOrder);\nconst newBalance = user.getBalance() - total;\nawait this.usersService.updateBalance(user.getId(), newBalance);\nrequest.session.products = null;\nconst viewData = [];\nviewData['title'] = 'Purchase - Online Store';\nviewData['subtitle'] = 'Purchase Status';\nviewData['orderId'] = order.getId();\nreturn response.render('cart/purchase', { viewData: viewData });\n}\n}\n}\nLet’s analyze the previous method by parts.\nAnalyze Code\n@Get('/purchase')\nasync purchase(@Req() request, @Res() response) {\nif (!request.session.user) {\nreturn response.redirect('/auth/login');\n} else if (!request.session.products) {\nreturn response.redirect('/cart');\n} else {\n",
      page_no: 105,
    },
    {
      id: 122,
      bookId: 33,
      content:
        "We define the purchase method that is the most complex in this book. In the beginning, we check if there is user\ninformation in session (the user is logged in), if there is not, we redirect the user to the (“/auth/login”) route. Then,\nwe check if the user has products in session. If there are no products in session, we redirect the user to the (“/cart”)\nroute.\nAnalyze Code\nconst user = await this.usersService.findOne(request.session.user.id);\nconst productsInSession = request.session.products;\nconst productsInCart = await this.productsService.findByIds(\nObject.keys(productsInSession),\n);\nlet total = 0;\nconst items: Item[] = [];\nIf the user is logged in and there are products in session, we start the purchase process. We extract the user\ninformation from the user variable using the request.session.user.id  data. We extract the products info from the\nsession and extract the corresponding products from the database. Then, we define a total  variable with a value of\n0  and create an empty array of items.\nAnalyze Code\nfor (let i = 0; i < productsInCart.length; i++) {\nconst quantity = productsInSession[productsInCart[i].getId()];\nconst item = new Item();\nitem.setQuantity(quantity);\nitem.setPrice(productsInCart[i].getPrice());\nitem.setProduct(productsInCart[i]);\nitems.push(item);\ntotal = total + productsInCart[i].getPrice() * quantity;\n}\nWe iterate through the productsInCart  array. For each product in productsInCart , we create a new  Item , and set\nthe corresponding quantity  (based on the values stored in session), price , and product . We then add the item to\nthe  items  array, and update the total  value.\nAnalyze Code\nconst newOrder = new Order();\nnewOrder.setTotal(total);\nnewOrder.setItems(items);\nnewOrder.setUser(user);\nconst order = await this.ordersService.createOrUpdate(newOrder);\nWe create a  newOrder  instance, set total ,  items , user  and store it in the database. Since we set to newOrder  an\narray of items with cascade insert , the order and all its items will be added into the database.\nAnalyze Code\nconst newBalance = user.getBalance() - total;\nawait this.usersService.updateBalance(user.getId(), newBalance);\nrequest.session.products = null;\nconst viewData = [];\nviewData['title'] = 'Purchase - Online Store';\nviewData['subtitle'] = 'Purchase Status';\nviewData['orderId'] = order.getId();\nreturn response.render('cart/purchase', { viewData: viewData });\nWe calculate and set the new user’s balance . We then remove the products in session and show the cart/purchase\nview with orderId .\nNote: we have not verified if the user has enough money to purchase. Try to include that validation in the previous\ncode. You can use the discussion zone of the book repository to show us your solution.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow, log in to the application, go to the (“/products”) route, and add some products to the cart (see Fig. 27-1). Click\nthe Purchase  button and the application will show a confirmation message (see Fig. 27-2). Next, you can open\nphpMyAdmin and check that the orders  table (see Fig 27-3), and items  table (see Fig. 27-4) contain the new data.\n",
      page_no: 106,
    },
    {
      id: 123,
      bookId: 33,
      content:
        "Figure 27-1. Shopping cart with some products.\nFigure 27-2. Purchase completed message.\nFigure 27-3. New order row included in the database.\nFigure 27-4. New item rows included in the database.\n",
      page_no: 107,
    },
    {
      id: 124,
      bookId: 33,
      content:
        "Chapter 28 – Orders Page\nLet’s finish our Online Store application. We will create a page where users can list their orders.\nAccount Module\nThe AccountModule  will be used to manage user accounts. In this book, we will only implement listing user\norders, but in real-world applications, you can extend this module to enable users to modify their information or set\npreferences. Let’s begin.\nCreating AccountController\nIn src/ , create a subfolder called account . Then, in src/account  create a new file account.controller.ts  and fill it\nwith the following code.\nAdd Entire Code\nimport { Controller, Get, Render, Req } from '@nestjs/common';\nimport { OrdersService } from '../models/orders.service';\n@Controller('/account')\nexport class AccountController {\nconstructor(private readonly ordersService: OrdersService) {}\n@Get('/orders')\n@Render('account/orders')\nasync orders(@Req() request) {\nconst viewData = [];\nviewData['title'] = 'My Orders - Online Store';\nviewData['subtitle'] = 'My Orders';\nviewData['orders'] = await this.ordersService.findByUserId(\nrequest.session.user.id,\n);\nreturn {\nviewData: viewData,\n};\n}\n}\nWe have an AccountController  with an  orders  method linked to the (“/account/orders”) route. This is a simple\nmethod that searches the orders of the logged in user (based on the request.session.user.id data). We use\nthis.ordersService.findByUserId  method to extract those orders (will be implemented later). Finally, we render the\naccount/orders  view.\nModifying Orders Service\nIn src/models/orders.service.ts , make the following changes in bold.\nModify Bold Code\n...\n@Injectable()\nexport class OrdersService {\n...\nfindByUserId(id: number): Promise<Order[]> {\nreturn this.ordersRepository.find({\nwhere: {\nuser: { id: id },\n},\nrelations: ['items', 'items.product'],\n});\n}\n}\nWe include the findByUserId  method. This method receives a user id  and finds the orders related to that user\nid . Note that we pass a relations  option to the TypeORM Repository find  method. The relations option is used to\ninform the repository that we need to extract not only the orders information, but also the items  related to those\norders , and even products  related to the items  related to the orders . This is the power of the TypeORM\nrelations. If properly implemented, it allows us to navigate across our class diagram. We will navigate across these\nrelations later in the orders view.\nCreating Account Module\n",
      page_no: 108,
    },
    {
      id: 125,
      bookId: 33,
      content:
        'In src/account  create a new file account.module.ts  and fill it with the following code.\nAdd Entire Code\nimport { Module } from \'@nestjs/common\';\nimport { AccountController } from \'./account.controller\';\n@Module({\ncontrollers: [AccountController],\n})\nexport class AccountModule {}\nWe created AccountModule  and registered AccountController .\nModifying AppModule\nLet’s register AccountModule  in the application root module ( AppModule ). In src/app.module.ts , make the\nfollowing changes in bold.\nModify Bold Code\n…\nimport { AuthModule } from \'./auth/auth.module\';\nimport { CartModule } from \'./cart/cart.module\';\nimport { AccountModule } from \'./account/account.module\';\n@Global()\n@Module({\nimports: [\nTypeOrmModule.forRoot(),\nTypeOrmModule.forFeature([Product, User]),\nAdminModule,\nAuthModule,\nCartModule,\nAccountModule,\n],\n…\nAccount orders view\nIn views/ , create a subfolder called account . Then, in views/account  create a new file orders.hbs  and fill it with\nthe following code.\nAdd Entire Code\n{{#> app}}\n{{#*inline "content"}}\n{{#each viewData.orders}}\n<div class="card mb-4">\n<div class="card-header">\nOrder #{{getId}}\n</div>\n<div class="card-body">\n<b>Date:</b> {{getDate}}<br />\n<b>Total:</b> ${{getTotal}}<br />\n<table class="table table-bordered table-striped text-center mt-3">\n<thead>\n<tr>\n<th scope="col">Item ID</th>\n<th scope="col">Product Name</th>\n<th scope="col">Price</th>\n<th scope="col">Quantity</th>\n</tr>\n<tbody>\n{{#each getItems}}\n<tr>\n<td>{{getId}}</td>\n{{#with getProduct}}\n<td>\n<a class="link-success" href="/products/{{getId}}">\n{{getName}}\n</a>\n</td>\n{{/with}}\n<td>${{getPrice}}</td>\n<td>{{getQuantity}}</td>\n</tr>\n{{/each}}\n</tbody>\n</thead>\n</table>\n',
      page_no: 109,
    },
    {
      id: 126,
      bookId: 33,
      content:
        '</div>\n</div>\n{{else}}\n<div class="alert alert-danger" role="alert">\nSeems to be that you have not purchased anything in our store =(.\n</div>\n{{/each}}\n{{/inline}}\n{{/app}}\nWe use a each  hbs helper to iterate through the viewData.orders . If the user has no orders, we use the else  hbs\nhelper to show a message saying “you have not purchased anything”. Otherwise, we show each order’s date  and\ntotal (using the respective getters). Then, we have a second each  helper. This time, we iterate through the items of\neach order (using getItems ). We show each item’s id , price , and quantity . Finally, we use the with  hbs helper\nto access the product properties of each item (using getProduct ) and display the product name  and link to the\nrespective product page.\nUpdating link in app layout\nNow that we have the proper orders route, let’s include it in the app  layout. In views/layouts/app.hbs , make the\nfollowing changes in bold.\nModify Bold Code\n<!doctype html>\n...\n{{#if session.user}}\n<a class="nav-link active" href="/account/orders">My Orders</a>\n<a class="nav-link active" href="/auth/logout">Logout ({{session.user.name}})</a>\n{{else}}\n<a class="nav-link active" href="/auth/login">Login</a>\n<a class="nav-link active" href="/auth/register">Register</a>\n{{/if}}\n...\nWe added a new link to My Orders page.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow, log in to the application, go to the (“/account/orders”) route, and you will see your orders (see Fig. 28-1).\nFigure 28-1. Online Store – My Orders page.\nRefactoring My Orders page\nThe current date format looks messy. Another problem is that anyone (logged user or not) can access the\n(“/account/orders”) route (by placing that route in the browser). Let’s fix these two issues before completing our\napplication.\nModifying Order Entity\nIn src/models/order.entity.ts , make the following changes in bold.\n',
      page_no: 110,
    },
    {
      id: 127,
      bookId: 33,
      content:
        "Modify Bold Code\n...\n@Entity()\nexport class Order {\n...\ngetDate(): string {\nreturn this.date.toISOString().split('T')[0];\n}\n...\nWe modify the getDate  method to return a string , and use the toISOString  method to return a date object as a\nstring using the ISO standard( YYYY-MM-DDTHH:mm:ss ). We remove the time portion ( THH:mm:ss ) of that\nstandard.\nModifying main.ts\nIn src/main.ts , make the following changes in bold.\nModify Bold Code\n...\n});\napp.use('/account*', function (req, res, next) {\nif (req.session.user) {\nnext();\n} else {\nres.redirect('/');\n}\n});\nawait app.listen(3000);\n}\nbootstrap();\nWe create a new middleware which applies for routes that begins with the (“/account”) string (all our account\nroutes). We check if there is a req.session.user  property. If true, it means that the current user is logged in and can\naccess the current route. We then call the next()  method to continue to the next middleware. Otherwise, redirect the\nuser to the home page.\nRunning the app\nIn the Terminal, go to the project directory, and execute the following:\nExecute in Terminal\nnpm run start:dev\nNow, log in to the application, go to the (“/account/orders”) route, and you will see your orders with the new date\nformat (see Fig. 28-2). Again, this illustrates the usefulness of getters in action.\nFigure 28-2. Online Store – Orders page with new date format.\nWe have finished our application. Congratulations! We hope you now better understand our architecture diagram\nand its elements (see Fig. 28-3).\n",
      page_no: 111,
    },
    {
      id: 128,
      bookId: 33,
      content:
        "Figure 28-3. Online Store software architecture.\nLet’s have a quick final analysis.\n• We integrated MVC into our software architecture.\n• We have proper consistency between the architecture diagram, class diagram, and the developed code. For\nexample, the architecture diagram shows four entities, corresponding to the class diagram classes, and those\nentities are coded adequately into the src/models  folder.\n• The diagram serves to understand how the application is connected, how each layer or file invokes other layers\nor files. You can even deduce some architectural rules from that diagram. For example, you cannot invoke\nviews or models from a module file. Or it is not allowed to invoke views from a model file. This is useful to\nkeep our application code clean and flexible to evolving changes.\nTIP: Use what you learnt from the diagram to complete your architectural rules document. You\ncan use some of the rules described. Share the architecture and class diagrams with your\ncolleagues. For example, store these documents in a repository that is easily found and\naccessible.\nWhat an exciting journey! We have completed our Online Store with an MVC architecture. Let’s have a final tip\nand discussion, before deploying our application to the cloud.\nTIP: A final quote from the (2019 - Thomas, D., & Hunt, A. - The Pragmatic Programmer: your\njourney to mastery) book. “Critically Analyze What You Read and Hear”. That video you saw\non YouTube, that post you read in StackOverFlow, this paragraph that you are reading in this\nbook. Does it make sense? Is it a good strategy? Does it apply to your context? Is it true?\nQuick discussion: Have you seen the “Harry Potter and the Half-Blood Prince” film? In the\nfilm, Harry Potter was enrolled in a potions class. The class had an “Advanced Potion-Making”\ntextbook which contained a variety of recipes for various potions. Harry had not bought his own\ntextbook. So, the potions professor loaned one of the older books (left behind by previous\n",
      page_no: 112,
    },
    {
      id: 129,
      bookId: 33,
      content:
        'students) to Harry. This book belonged to Severus Snape whose nickname was the "Half-Blood\nPrince". Snape improved many of the potions by means of including procedures and scribbling\nnotes in the margins. Harry tried Snape\'s methods and achieved the best results in the class. We\nall should be like the Half-Blood Prince, trying to critically analyze everything and make our\nown judgements. Book authors make mistakes, experts make mistakes, we all make mistakes.\nThere is still room for improvement.\n',
      page_no: 113,
    },
    {
      id: 130,
      bookId: 33,
      content:
        "Chapter 29 – Deploying to the Cloud – Clever-Cloud –\nMySQL Database\nNow, we will learn how to deploy our application to the cloud using a free cloud server.\nIntroduction to Clever-Cloud\nClever Cloud is a ‘Platform as a Service’ company that helps developers deploy and run their apps over the cloud.\nIn addition, Clever Cloud offers free service trials, such as the MySQL service. With this service, we will deploy,\nrun, and monitor our MySQL databases and tables.\nCreating a Clever Cloud account\nLet’s create a Clever Cloud account. Go to https://api.clever-cloud.com/v2/session/signup and complete the “Sign\nup with Email” information (see Fig. 29-1).\nFigure 29-1. Clever Cloud Sign up page.\nValidate your email. After that, access https://console.clever-cloud.com/, click Personal space , Create… , and\nclick an add-on . After that, select MySQL , choose the  DEV  plan  option (the first one), which costs 0.00€, and\nclick next . Then, put onlineStore  as the add-one name, leave the region as it appears, and click next  (see Fig. 29-\n2). We have created our MySQL cloud service.\nFigure 29-2. Clever Cloud MySQL add-on creation.\nAfter the MySQL creation, we will see a dashboard (see Fig. 29-3), which contains our “Database Credentials” and\na link to “phpMyAdmin”. We will use this information next.\n",
      page_no: 114,
    },
    {
      id: 131,
      bookId: 33,
      content:
        'Figure 29-3. Clever Cloud MySQL add-on creation.\nNote: if for any reason, Clever Cloud disables the DEV free plan , just create a new topic in the discussion zone of\nthe book repo, and we will make a tutorial with an alternative platform.\nCloning our application\nLet’s make a copy of our application code. Copy all the content of your online-store  folder to a new folder called\nonline-store-cloud  (in a location of your choice).\nModifying the .env file\nTo execute the database queries over our cloud database, we need to modify the .env  file (located at the cloud\nproject root folder).\nGo to your online-store-cloud  folder, and in the ormconfig.json file, make the following changes in bold. Replace\nthe \nDATABASE_CREDENTIALS_HOST , \nDATABASE_CREDENTIALS_DATABASE_NAME ,\nDATABASE_CREDENTIALS_USER , and DATABASE_CREDENTIALS_PASSWORD  with your values (from the\n“Clever Cloud addon dashboard”, presented previously).\nModify Bold Code with Your Values\n{\n    "type": "mysql",\n"host": "DATABASE_CREDENTIALS_HOST",\n    "port": 3306,\n    "username": "DATABASE_CREDENTIALS_USER",\n    "password": "DATABASE_CREDENTIALS_PASSWORD",\n    "database": "DATABASE_CREDENTIALS_DATABASE_NAME",\n    "entities": ["dist/**/*.entity{.ts,.js}"],\n    "synchronize": true\n}\nYou will get something like the following.\nAnalyze Code\n{\n"type": "mysql",\n"host": "b6ejrgireod7ueb9yryu-mysql.services.clever-cloud.com",\n"port": 3306,\n"username": "u1ta1it4vk9ffz38",\n"password": "Vz0QqTGQaZ5fmAa8n…",\n"database": "b6ejrgireod7ueb9yryu",\n"entities": ["dist/**/*.entity{.ts,.js}"],\n"synchronize": true\n}\nSynchronizing the database\nLet’s synchronize our database. In the Terminal, go to the cloud project directory, and execute the following:\n',
      page_no: 115,
    },
    {
      id: 132,
      bookId: 33,
      content:
        "Execute in Terminal\nnpm run start:dev\nNow, if you go to the Clever Cloud “phpMyAdmin” tab, you will see the tables properly created (see Fig. 29-4).\nFigure 29-4. Accessing phpMyAdmin over the Clever Cloud database.\nExporting and Importing our data\nWe currently have empty tables. Let’s copy the data from our local database to our cloud database. Open\n“phpMyAdmin” from your local computer. Go to the online_store  database, go to the Export  tab, and select\n“export method” as Custom . In tables, deselect all the Structure  options, and in Data , select all. Finally, click\nGo  (see Fig. 29-5).\nFigure 29-5. Exporting the data from the local database.\nYou will get a SQL file. This file contains our application data. Then, go to the cloud database, go to\n“phpMyAdmin”, go to your cloud database, click the  Import  tab, select the SQL file, deselect the Enable foreign\nkey checks  option, and click Go  (see Fig. 29-6).\n",
      page_no: 116,
    },
    {
      id: 133,
      bookId: 33,
      content:
        "Figure 29-6. Importing the data to the cloud database.\nCongratulations, we have our database and data in the cloud. You can check that your data was successfully\nuploaded by opening the product  or user  table (see Fig. 29-7).\nFigure 29-7. Browsing the product  table.\n",
      page_no: 117,
    },
    {
      id: 134,
      bookId: 33,
      content:
        'Chapter 30 – Deploying to the Cloud – Heroku – Nest\nApplication\nNow, let’s deploy our Nest code over the cloud.\nCreating a Heroku account\nLet’s create a Heroku account. First, access https://signup.heroku.com/, complete the information, and click “Create\nFree Account”. Next, confirm your email address and set up your password.\nInstalling Git\nInstall git by following the instruction in this link: https://git-scm.com/.\nInitializing a Git repository\nGo to the cloud project directory, and in the Terminal, execute the following commands.\nExecute in Terminal\ngit init\ngit add .\ngit commit -m "new nest project"\nThe commands initialize a Git repository and commit the current state.\nInstalling Heroku CLI\nThe Heroku Command Line Interface (CLI) makes it easy to create and manage our Heroku apps directly from the\nterminal. Follow the installation instructions from this link: https://devcenter.heroku.com/articles/heroku-cli.\nDeploying to Heroku\nProcfile\nTo deploy our application to Heroku, you must create a Procfile  file, which tells Heroku what settings to use to\nlaunch the web server. In the cloud project root folder, create a new file called Procfile  (without any extension),\nand fill it with the following code.\nAdd Entire Code\nweb: npm run start:prod\nHeroku executes the command in start:prod  script defined in package.json .\nModifying main.ts\nIn src/main.ts , make the following changes in bold.\nModify Bold Code\n…  \nawait app.listen(process.env.PORT || 8080);\n}\nbootstrap();\nWhen we developed the Nest application, we used the port 3000, but this won\'t work with Heroku. So, we need to\nuse an environment variable (if defined) or the classic port 8080.\nModifying package.json\nHeroku needs to know the version of your Node.js runtime to be able to run it on Heroku. You can check for your\nnode version by running the following command in your terminal:\nExecute in Terminal\nnode -v\nIn our case, it showed v16.13.1 . Based on that, we need to modify our package.json . In package.json , make the\nfollowing changes in bold.\nModify Bold Code\n…  \n"testEnvironment": "node"\n},\n',
      page_no: 118,
    },
    {
      id: 135,
      bookId: 33,
      content:
        '"engines": {\n"node": "16.x"\n}\n}\nWe set the node engine to 16.x, meaning it will take one of the node 16.x versions.\nCommitting changes\nSince we added a new file and modified others, we need to include them in a new commit. So, go to the cloud\nproject directory, and in the Terminal, execute the following commands.\nExecute in Terminal\ngit add .\ngit commit -m "configuring app for heroku deployment"\nCreating a new application on Heroku\nTo create a new Heroku application, we use the heroku create  command. Go to the cloud project directory, and in\nthe Terminal, execute the following command.\nExecute in Terminal\nheroku create\nThis command creates a Heroku application. Sometimes, the command will open a browser tab to prompt us to log\nin to the Heroku website (if that is your case, please complete the log-in process). At the end, it provides a link with\nour new Heroku application deployed in the cloud (see Fig. 30-1).\nFigure 30-1. Creating a Heroku application.\nIf you access the link (in our case it was https://infinite-stream-65085.herokuapp.com/), you will see a default\napplication with a welcome message (see Fig. 30-2).\nFigure 30-2. Accessing the Heroku application.\nPushing to Heroku\nNext, it’s time to deploy our application to Heroku. Go to the cloud project directory, and in the Terminal, execute\nthe following command.\nExecute in Terminal\ngit push heroku master\nOpen your application with the following command.\nExecute in Terminal\nheroku open\nYou will see the complete Online Store application running over the cloud (see Fig. 30-3).\n',
      page_no: 119,
    },
    {
      id: 136,
      bookId: 33,
      content:
        "Figure 30-3. Online Store running over the cloud.\nNote: If you get a 500 error, it means you didn’t configure your database credentials properly.\n",
      page_no: 120,
    },
    {
      id: 137,
      bookId: 33,
      content:
        "Chapter 31 – Continue your Nest Journey\nWe have learned a lot since we started. We took a practical journey to master the design and implementation of\nMVC web applications with Nest. We developed a real-world project in which we applied a lot of different Nest\nfunctionalities. We purposely made code mistakes, but we fixed it and learned some practical tips about clean code\n(not only for Nest projects but for any web MVC project).\nThere are missing elements we didn’t address in this book. So, we will show you additional interesting links and\nconcepts of Nest where you can learn independently. We will also give you some book recommendations.\nOther Nest interesting features\n• Testing. \nDo \nyou \nwant \nto \ntest \nyour \nNest \napplication? \nCheck \nNest \ntesting\nhttps://docs.nestjs.com/fundamentals/testing.\n• Cache. Do you want to cache some parts of your application and improve your app's performance? Check Nest\ncache https://docs.nestjs.com/techniques/caching.\n• Custom decorators. Do you want to create your own decorators? Check Nest custom decorators\nhttps://docs.nestjs.com/custom-decorators.\n• Passport. \nThis \nis \na \nrecommended \nauthentication \nsystem \nfor \nNest \nAPI \napplications.\nhttps://docs.nestjs.com/security/authentication.\n• Pipes. This is a recommended validation system for Nest API applications. https://docs.nestjs.com/pipes.\n• Guards. \nThis \nis \na \nrecommended \nauthorization \nsystem \nfor \nNest \nAPI \napplications.\nhttps://docs.nestjs.com/guards.\nRecommended books\nDo you want to learn other frameworks and other types of software architectures? We have some recommendations.\n• Beginning Django 4: Build Full Stack Python Web Applications (By Greg Lim and Daniel Correa)\nhttps://www.amazon.com/gp/product/B09M2N778S - this is a book where we design an MVT architecture\nwith Django (Python). We don’t have some clean code strategies and diagrams as we did in this book, but it is\na great book for beginners.\n• Beginning Vue Stack: Build and Deploy a Full Stack MongoDB, Express, Vue.js, Node.js App (By Greg\nLim and Daniel Correa) https://www.amazon.com/gp/product/B09G9V44MN - Do you want to split your\napplication into two parts (front-end and back-end)? You can use this book as a base. We will design two\napplications: a front-end with Vue.js (which follows an MVVM architecture) and a backend with Express\n(Node.js). In the process, you will learn another database system (MongoDB).\n• Finally, go to Amazon and look for Greg Lim’s books (https://www.amazon.com/Greg-Lim/e/B06XP6FHDK).\nFinal remarks and future books\nAcross our books, we have developed an extensive range of web applications with different architectures (not only\nMVC). E.g., applications with separated front-end and back-end, service-oriented architectures (SOA), and even\nmicro-services. We are developing books similar to this on Laravel (PHP), Django (Python), and Spring (Java), so\nkeep checking Daniel’s Twitter account (@danielgarax) and Greg’s Twitter account (@greglim81) for updates.\nWe would love to get your feedback. Contact us at practicalbooksco@gmail.com. Please let us know what you\nliked and what you didn’t. That’s the way all of us improve as web developers. It is something that we do very\nconstantly, writing to book authors, with questions, suggestions, critics, and both author and readers learn a lot in\nthis process.\nFinally, please try to leave an honest review on Amazon. This is vital so that other potential readers can see and\nuse your unbiased opinion to buy the book and understand what people like and didn’t like about the book. It will\nonly take a few minutes of your time but is very valuable to us.\n“Hecho en Medellín”\n",
      page_no: 121,
    },
  ],
  user: [
    {
      id: 1,
      username: "John",
      password: "password",
    },
    {
      id: 2,
      username: "Doe",
      password: "password",
    },
    {
      id: 3,
      username: "James",
      password: "password",
    },
  ],
  bookmark: [
    {
      id: 1,
      userId: 1,
      bookId: 1,
      book_content_page_no: 2,
    },
    {
      id: 2,
      userId: 1,
      bookId: 2,
      book_content_page_no: 2,
    },
    {
      id: 3,
      userId: 2,
      bookId: 1,
      book_content_page_no: 2,
    },
    {
      id: 4,
      userId: 3,
      bookId: 3,
      book_content_page_no: 2,
    },
    {
      id: 5,
      userId: 1,
      bookId: 1,
      book_content_page_no: 1,
    },
    {
      id: 6,
      userId: 1,
      bookId: 1,
      book_content_page_no: 5,
    },
    {
      id: 7,
      userId: 1,
      bookId: 1,
      book_content_page_no: 9,
    },

    {
      id: 8,
      userId: 1,
      bookId: 2,
      book_content_page_no: 1,
    },
    {
      id: 9,
      userId: 1,
      bookId: 33,
      book_content_page_no: 33,
    },
    {
      id: 10,
      userId: 1,
      bookId: 33,
      book_content_page_no: 5,
    },
    {
      id: 11,
      userId: 1,
      bookId: 33,
      book_content_page_no: 50,
    },
    {
      id: 12,
      userId: 1,
      bookId: 33,
      book_content_page_no: 44,
    },
  ],
  bookUser: [
    {
      bookId: 1,
      userId: 1,
      resumePage: 0,
      isWish: false,
    },
    {
      bookId: 1,
      userId: 2,
      resumePage: 0,
      isWish: false,
    },
    {
      bookId: 1,
      userId: 3,
      resumePage: 0,
      isWish: false,
    },
  ],
  booksList: [
    {
      bookId: 1,
      authId: 1,
      cateId: 1,
    },
    {
      bookId: 2,
      authId: 1,
      cateId: 1,
    },
    {
      bookId: 3,
      authId: 1,
      cateId: 1,
    },
    {
      bookId: 4,
      authId: 2,
      cateId: 2,
    },
    {
      bookId: 5,
      authId: 2,
      cateId: 2,
    },
    {
      bookId: 6,
      authId: 2,
      cateId: 2,
    },
    {
      bookId: 7,
      authId: 3,
      cateId: 3,
    },
    {
      bookId: 8,
      authId: 3,
      cateId: 3,
    },
    {
      bookId: 9,
      authId: 3,
      cateId: 3,
    },
    {
      bookId: 33,
      authId: 3,
      cateId: 3,
    },
  ],
  progressingBook: [
    {
      id: 1,
      userId: 1,
      bookId: 1,
      resumePage: 1,
      progressingPercent: 20,
    },
    {
      id: 2,

      userId: 1,
      bookId: 2,
      resumePage: 1,
      progressingPercent: 80,
    },
    {
      id: 3,

      userId: 1,
      bookId: 3,
      resumePage: 1,
      progressingPercent: 40,
    },
    {
      userId: 1,
      bookId: 4,
      resumePage: 1,
      progressingPercent: 90,
    },
    {
      id: 4,
      userId: 1,
      bookId: 4,
      resumePage: 1,
      progressingPercent: 90,
    },
    {
      id: 5,
      userId: 2,
      bookId: 2,
      resumePage: 1,
      progressingPercent: 0,
    },
    {
      id: 6,
      userId: 2,
      bookId: 3,
      resumePage: 1,
      progressingPercent: 0,
    },
  ],
};
module.exports = data;
